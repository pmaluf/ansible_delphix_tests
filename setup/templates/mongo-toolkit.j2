{
    "discoveryDefinition": {
        "manualSourceConfigDiscovery": true, 
        "sourceConfigNameField": "prettyName", 
        "repositoryIdentityFields": [
            "mongoInstallPath", 
            "mongoShellPath"
        ], 
        "repositorySchema": {
            "additionalProperties": false, 
            "type": "object", 
            "properties": {
                "version": {
                    "prettyName": "Version", 
                    "type": "string", 
                    "description": "MongoDB Version"
                }, 
                "mongoInstallPath": {
                    "prettyName": "Mongo Install Path", 
                    "type": "string", 
                    "description": "Path to Mongo binaries"
                }, 
                "mongoShellPath": {
                    "prettyName": "Mongo Shell Path", 
                    "type": "string", 
                    "description": "Path to Mongo Shell"
                }, 
                "prettyName": {
                    "prettyName": "Pretty Name", 
                    "type": "string", 
                    "description": "Pretty name of this repository"
                }
            }
        }, 
        "sourceConfigDiscovery": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\nenv = {\n   DLPX_TOOLKIT_WORKFLOW=\"sourceConfigDiscovery\",\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   MONGO_VERSION = repository.version,\n   MONGO_INSTALL_PATH = repository.mongoInstallPath,\n   MONGO_SHELL = repository.mongoShellPath\n}\n\nreturn RunBash {\n  command = resources[\"sourceConfigDiscovery.sh\"],\n  environment = remote.environment,\n  user = remote.environmentUser,\n  host = remote.host,\n  variables = env,\n  outputSchema = {\n    type = \"array\",\n    items = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n        dbPath = { type=\"string\" },\n        mongoPort = { type=\"integer\" },\n        replicaSet = { type=\"string\" },\n        mongoHost = { type=\"string\" },\n        discoveryType = { type=\"string\" },\n        prettyName = { type=\"string\" }\n      }\n    }\n  }\n}\n", 
        "repositoryNameField": "prettyName", 
        "repositoryDiscovery": "--\n-- Copyright (c) 2015 by Delphix. All rights reserved.\n--\nenv = {\n   DLPX_TOOLKIT_WORKFLOW=\"repositoryDiscovery\",\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nrepoConfigfile = RunBash{\n   command     = resources[\"getMongoRepoCfgFile.sh\"],\n   environment = remote.environment,\n   user        = remote.environmentUser,\n   host        = remote.host,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n\n-- errorMessage = messages.errormessage(repoConfigfile)\n-- Fail(errorMessage)\n\nif repoConfigfile == \"SKIP_MANUALREPODISCOVERY\" then\n    repoConfigfile = 'ManualRepoDiscoveryFileNotProvided'\nend\n\nenv = {\n   DLPX_TOOLKIT_WORKFLOW=\"repositoryDiscovery\",\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_REPO_CFGFILE=repoConfigfile\n} \n\nreturn RunBash {\n  command = resources[\"repoDiscovery.sh\"],\n  environment = remote.environment,\n  user = remote.environmentUser,\n  host = remote.host,\n  variables = env,\n  outputSchema = {\n    type = \"array\",\n    items = {\n      type=\"object\",\n      additionalProperties = false,\n      properties = {\n        mongoInstallPath  = { type=\"string\" },\n        mongoShellPath  = { type=\"string\" },\n        version      = { type=\"string\" },\n        prettyName   = { type=\"string\" }\n      }\n    }\n  }\n}\n", 
        "sourceConfigSchema": {
            "additionalProperties": false, 
            "ordering": [
                "mongoHost", 
                "mongoPort", 
                "dbPath", 
                "replicaSet", 
                "discoveryType", 
                "prettyName"
            ], 
            "required": [
                "mongoHost", 
                "mongoPort", 
                "dbPath", 
                "replicaSet", 
                "discoveryType", 
                "prettyName"
            ], 
            "type": "object", 
            "properties": {
                "dbPath": {
                    "default": "", 
                    "prettyName": "DB Data Path", 
                    "type": "string", 
                    "description": ""
                }, 
                "replicaSet": {
                    "default": "", 
                    "prettyName": "Replica Set Name", 
                    "type": "string", 
                    "description": ""
                }, 
                "discoveryType": {
                    "default": "Manual", 
                    "enum": [
                        "Manual", 
                        "Auto"
                    ], 
                    "type": "string", 
                    "description": "", 
                    "prettyName": "discoveryType"
                }, 
                "mongoPort": {
                    "default": 0, 
                    "prettyName": "Source Mongo Port", 
                    "type": "integer", 
                    "description": "Note : Enter Staging Host unused port if Mongo OPS Manager Automation manages replicaset"
                }, 
                "prettyName": {
                    "default": "", 
                    "prettyName": "Identity Field", 
                    "type": "string", 
                    "description": "Recommended : Mongo_Port"
                }, 
                "mongoHost": {
                    "default": "", 
                    "prettyName": "Source Host", 
                    "type": "string", 
                    "description": "Note : Enter Staging Host if Mongo OPS Manager Automation manages replicaset"
                }
            }
        }, 
        "type": "ToolkitDiscoveryDefinition", 
        "sourceConfigIdentityFields": [
            "dbPath", 
            "prettyName"
        ]
    }, 
    "snapshotSchema": {
        "additionalProperties": false, 
        "type": "object", 
        "properties": {
            "dSourceType": {
                "type": "string"
            }, 
            "mongoAuth": {
                "type": "string"
            }, 
            "replicaSet": {
                "type": "string"
            }, 
            "storageEngine": {
                "type": "string"
            }, 
            "appenddbPath": {
                "type": "string"
            }, 
            "toolkitVersion": {
                "type": "string"
            }, 
            "timestamp": {
                "type": "string"
            }, 
            "journalInterval": {
                "type": "integer"
            }, 
            "mongoPort": {
                "type": "integer"
            }, 
            "osType": {
                "type": "string"
            }, 
            "mongoDBPassword": {
                "type": "string"
            }, 
            "oplogSize": {
                "type": "integer"
            }, 
            "mongoDBUser": {
                "type": "string"
            }, 
            "architecture": {
                "type": "string"
            }, 
            "delphixMount": {
                "type": "string"
            }, 
            "mongoVersion": {
                "type": "string"
            }, 
            "osVersion": {
                "type": "string"
            }
        }
    }, 
    "name": "mongo", 
    "language": "LUA", 
    "linkedSourceDefinition": {
        "status": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {}\nenv.DLPX_TOOLKIT_WORKFLOW = \"status\"\nload(resources[\"getStagingConfig.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"status\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_SHELL=mongo_shell,\n   MONGO_HOST=parameters.mongoHost,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_STATUS_TYPE=\"staging\",\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\nif parameters.dSourceType == \"mongodump\" then\n  env.MONGO_STATUS_TYPE=\"mongodump\"\nend\n\nreturn RunBash {\n  command      = resources['status.sh'],\n  environment  = source.stagingEnvironment,\n  user         = source.stagingEnvironmentUser,\n  host         = source.stagingHost,\n  variables    = env,\n  outputSchema = { type = 'string' }\n}\n", 
        "parameters": {
            "additionalProperties": false, 
            "ordering": [
                "dSourceType", 
                "mongoHost", 
                "mongoPort", 
                "bindIP", 
                "keyfilePath", 
                "storageEngine", 
                "oplogSize", 
                "journalInterval", 
                "mountPath", 
                "mongoDBUser", 
                "mongoDBPassword"
            ], 
            "required": [
                "dSourceType", 
                "mongoHost", 
                "mongoPort", 
                "bindIP", 
                "mountPath", 
                "mongoDBUser", 
                "mongoDBPassword"
            ], 
            "type": "object", 
            "properties": {
                "mongoPort": {
                    "default": 28000, 
                    "environmentVariable": "MONGO_PORT", 
                    "prettyName": "Staging Port Number", 
                    "type": "integer", 
                    "description": ""
                }, 
                "mountPath": {
                    "default": "", 
                    "prettyName": "Mount Path", 
                    "type": "string", 
                    "description": ""
                }, 
                "journalInterval": {
                    "default": 30, 
                    "environmentVariable": "MONGO_JOURNAL_FLUSH", 
                    "prettyName": "Journal Commit Interval (ms)", 
                    "type": "integer", 
                    "description": ""
                }, 
                "dSourceType": {
                    "description": "", 
                    "default": "Staging", 
                    "enum": [
                        "emptyStagingFS", 
                        "Staging", 
                        "mongodump"
                    ], 
                    "environmentVariable": "MONGO_DSOURCE_TYPE", 
                    "prettyName": "dSource Type", 
                    "type": "string"
                }, 
                "mongoDBPassword": {
                    "default": "", 
                    "prettyName": "MongoDB Password", 
                    "type": "string", 
                    "description": "", 
                    "format": "password"
                }, 
                "oplogSize": {
                    "default": 1024, 
                    "environmentVariable": "MONGO_OPLOG_SIZE", 
                    "prettyName": "Oplog Size (MB)", 
                    "type": "integer", 
                    "description": ""
                }, 
                "mongoDBUser": {
                    "default": "", 
                    "prettyName": "MongoDB Source Database User", 
                    "type": "string", 
                    "description": ""
                }, 
                "keyfilePath": {
                    "default": "", 
                    "prettyName": "KeyAuth Filename (Full Path)", 
                    "type": "string", 
                    "description": "KeyAuth Filename accessible on staging host by staging delphix environment o/s user"
                }, 
                "storageEngine": {
                    "description": "", 
                    "default": "wiredTiger", 
                    "enum": [
                        "mmapv1", 
                        "wiredTiger"
                    ], 
                    "environmentVariable": "MONGO_STORAGE_ENGINE", 
                    "prettyName": "Storage Engine", 
                    "type": "string"
                }, 
                "bindIP": {
                    "default": "0.0.0.0", 
                    "environmentVariable": "MONGO_BIND_IP", 
                    "prettyName": "bindIP String", 
                    "type": "string", 
                    "description": "CSV string of allowed IPs"
                }, 
                "mongoHost": {
                    "default": "", 
                    "environmentVariable": "MONGO_HOST", 
                    "prettyName": "Staging MongoDB Host", 
                    "type": "string", 
                    "description": ""
                }
            }
        }, 
        "worker": "", 
        "stopStaging": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {}\nenv.DLPX_TOOLKIT_WORKFLOW = \"stopStaging\"\nload(resources[\"getStagingConfig.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"stopStaging\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_HOST=parameters.mongoHost,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_INSTALL_PATH=mongo_install_path,\n   MONGO_SHELL=mongo_shell,\n   VDB_GUID=source.guid,\n   DELETE_FLAG=delete\n}\n\nif parameters.dSourceType == \"Staging\" then\n    delphixOwned = RunBash{\n       command     = resources[\"checkOwnership.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = { type = 'boolean' }\n    }\n\n    if delphixOwned then\n        if delete then\n            RunBash{\n               command     = resources[\"dropStagingFromPrimary.sh\"],\n               environment = source.stagingEnvironment,\n               user        = source.stagingEnvironmentUser,\n               host        = source.stagingHost,\n               variables   = env\n            }\n        end\n\n        RunBash{\n           command     = resources[\"shutdown.sh\"],\n           environment = source.stagingEnvironment,\n           user        = source.stagingEnvironmentUser,\n           host        = source.stagingHost,\n           variables   = env\n        }\n    end\nelseif parameters.dSourceType == \"emptyStagingFS\" then\n    RunBash{\n       command     = resources[\"shutdown.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env\n    }\nend", 
        "startStaging": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {}\nenv.DLPX_TOOLKIT_WORKFLOW = \"startStaging\"\nload(resources[\"getStagingConfig.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"startStaging\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_HOST=parameters.mongoHost,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_SRC_HOST=config.mongoHost,\n   MONGO_SRC_PORT=config.mongoPort,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_INSTALL_PATH=mongo_install_path,\n   MONGO_SHELL=mongo_shell,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\n-- RunBash{\n--    command     = resources[\"addStagingToPrimary.sh\"],\n--    environment = source.environment,\n--    user        = source.environmentUser,\n--    host        = source.host,\n--    variables   = env\n-- }\n\nif parameters.dSourceType == \"Staging\" then\n    RunBash{\n       command     = resources[\"startStaging.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env\n    }\nelseif parameters.dSourceType == \"emptyStagingFS\" then\n    msg = \"No Action Needed\"\nend\n", 
        "resync": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {}\nenv.DLPX_TOOLKIT_WORKFLOW = \"resync\"\nload(resources[\"getStagingConfig.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   VDB_GUID=source.guid,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"resync\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_HOST=parameters.mongoHost,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_INSTALL_PATH=mongo_install_path,\n   MONGO_SHELL=mongo_shell,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_SRC_HOST=config.mongoHost,\n   MONGO_SRC_PORT=config.mongoPort,\n   MONGO_SRC_USER_NAME=parameters.mongoDBUser,\n   MONGO_SRC_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_VERSION=repository.version,\n   MONGO_DSOURCE_TYPE=parameters.dSourceType\n}\n\n--check if its new dsource or resynchronize dsource. NO is resynchronize, YES is new dSource\nismountpointempty = RunBash{\n       command     = resources[\"checkEmptyMountPoint.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {type = \"string\"}\n}\n\nif ismountpointempty == \"NO\" then\n    delphixOwned = RunBash{\n       command     = resources[\"checkOwnership.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = { type = 'boolean' }\n    }\n\n    if delphixOwned then\n        RunBash{\n           command     = resources[\"dropStagingFromPrimary.sh\"],\n           environment = source.stagingEnvironment,\n           user        = source.stagingEnvironmentUser,\n           host        = source.stagingHost,\n           variables   = env\n        }\n\n        RunBash{\n           command     = resources[\"shutdown.sh\"],\n           environment = source.stagingEnvironment,\n           user        = source.stagingEnvironmentUser,\n           host        = source.stagingHost,\n           variables   = env\n        }\n    end\nend\n\nif parameters.dSourceType == \"Staging\" then\n    output = RunBash{\n       command     = resources[\"addStagingToPrimary.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {type = \"string\"}\n    }\n\n    if output ~= \"SUCCESS\" then\n        errorMessage = messages.errormessage(output)\n        Fail(errorMessage)\n    else\n\n        output = RunBash{\n           command     = resources[\"startStaging.sh\"],\n           environment = source.stagingEnvironment,\n           user        = source.stagingEnvironmentUser,\n           host        = source.stagingHost,\n           variables   = env,\n           outputSchema = {type = \"string\"}\n        }\n\n        if output ~= \"SUCCESS\" then\n            errorMessage = messages.errormessage(output)\n            Fail(errorMessage)\n        end\n\n    end\n\nelseif parameters.dSourceType == \"emptyStagingFS\" then\n    output = RunBash{\n       command     = resources[\"initiateStagingFS.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env\n    }\n\n    output = RunBash{\n       command     = resources[\"chmod777mountpoint.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env\n    }\n\nelseif parameters.dSourceType == \"mongodump\" then\n    output = RunBash{\n       command     = resources[\"mongoseedinstance.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {type = \"string\"}\n    }\n\n    if output ~= \"SUCCESS\" then\n        errorMessage = messages.errormessage(output)\n        Fail(errorMessage)\n    end\n\n    output = RunBash{\n       command     = resources[\"mongofulldumpandrestore.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {type = \"string\"}\n    }\n\n    if output ~= \"SUCCESS\" then\n        errorMessage = messages.errormessage(output)\n        Fail(errorMessage)\n    end\nend\n", 
        "preSnapshot": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {}\nenv.DLPX_TOOLKIT_WORKFLOW = \"preSnapshot\"\nload(resources[\"getStagingConfig.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"preSnapshot\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_INSTALL_PATH = mongo_install_path,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_SHELL = mongo_shell,\n   MONGO_HOST=parameters.mongoHost,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_SRC_HOST=config.mongoHost,\n   MONGO_SRC_PORT=config.mongoPort,\n   MONGO_SRC_USER_NAME=parameters.mongoDBUser,\n   MONGO_SRC_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_DSOURCE_TYPE=parameters.dSourceType\n}\n\nif parameters.dSourceType == \"mongodump\" then\n    output = RunBash{\n       command     = resources[\"mongopresnapsync.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {type = \"string\"}\n    }\n\n    if output ~= \"SUCCESS\" then\n        errorMessage = messages.errormessage(output)\n        Fail(errorMessage)\n    end\nend\n\noutput = RunBash{\n   command     = resources[\"fsyncLock.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n\nif output == \"SKIP_SAVEKEYFILE\" then\n    msg = \"Skipping next Step\"\nelse\n    if output ~= \"SUCCESS\" then\n        errorMessage = messages.errormessage(output)\n        Fail(errorMessage)\n    else\n        RunBash{\n           command     = resources[\"saveKeyFile.sh\"],\n           environment = source.stagingEnvironment,\n           user        = source.stagingEnvironmentUser,\n           host        = source.stagingHost,\n           variables   = env\n        }\n    end       \nend\n\noutput = RunBash{\n   command     = resources[\"updateconfigfile.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n", 
        "mountSpec": "--\n-- Copyright (c) 2015 by Delphix. All rights reserved.\n--\n\nmounts = {}\ntargetMountPath = parameters.mountPath\nreturn targetMountPath\n", 
        "type": "ToolkitLinkedStagedSource", 
        "postSnapshot": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nenv = {}\nenv.DLPX_TOOLKIT_WORKFLOW = \"postSnapshot\"\nload(resources[\"getStagingConfig.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"postSnapshot\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_SRC_HOST=config.mongoHost,\n   MONGO_SRC_PORT=config.mongoPort,\n   MONGO_REPLICASET=config.replicaSet,\n   MONGO_HOST=parameters.mongoHost,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STAGING_SERVER_BOOL=true,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_INSTALL_PATH = mongo_install_path,\n   MONGO_SHELL = mongo_shell,\n   MONGO_VERSION = repository.version,\n   MONGO_DSOURCE_TYPE=parameters.dSourceType\n}\n\noutput = RunBash{\n   command     = resources[\"fsyncUnlock.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n\nif output == \"SKIP_SAVEKEYFILE\" then\n    msg = \"Skipping next Step\"\n    return RunBash {\n      command     = resources[\"emptyrecordStatus.sh\"],\n      environment = source.stagingEnvironment,\n      user        = source.stagingEnvironmentUser,\n      host        = source.stagingHost,\n      variables   = env,\n      outputSchema = {\n        type = \"object\",\n        additionalProperties = false,\n        properties = {\n          toolkitVersion = { type=\"string\" },\n          timestamp      = { type=\"string\" },\n          architecture   = { type=\"string\" },\n          osType         = { type=\"string\" },\n          osVersion      = { type=\"string\" },\n          mongoVersion   = { type=\"string\" },\n          delphixMount   = { type=\"string\" },\n          mongoPort      = { type=\"integer\" },\n          storageEngine  = { type=\"string\" },\n          mongoAuth      = { type=\"string\" },\n          replicaSet     = { type=\"string\" },\n          journalInterval = { type=\"integer\" },\n          oplogSize      = { type=\"integer\" },\n          mongoDBUser  = { type=\"string\" },\n          mongoDBPassword  = { type=\"string\" },\n          dSourceType  = { type=\"string\" },\n          appenddbPath  = { type=\"string\" }\n       }\n      }\n    }\nelse\n    if output ~= \"SUCCESS\" then\n      errorMessage = messages.errormessage(output)\n      Fail(errorMessage)\n    end\n\n    return RunBash {\n      command     = resources[\"recordStatus.sh\"],\n      environment = source.stagingEnvironment,\n      user        = source.stagingEnvironmentUser,\n      host        = source.stagingHost,\n      variables   = env,\n      outputSchema = {\n        type = \"object\",\n        additionalProperties = false,\n        properties = {\n          toolkitVersion = { type=\"string\" },\n          timestamp      = { type=\"string\" },\n          architecture   = { type=\"string\" },\n          osType         = { type=\"string\" },\n          osVersion      = { type=\"string\" },\n          mongoVersion   = { type=\"string\" },\n          delphixMount   = { type=\"string\" },\n          mongoPort      = { type=\"integer\" },\n          storageEngine  = { type=\"string\" },\n          mongoAuth      = { type=\"string\" },\n          replicaSet     = { type=\"string\" },\n          journalInterval = { type=\"integer\" },\n          oplogSize      = { type=\"integer\" },\n          mongoDBUser  = { type=\"string\" },\n          mongoDBPassword  = { type=\"string\" },\n          dSourceType  = { type=\"string\" },\n          appenddbPath  = { type=\"string\" }\n       }\n      }\n    }\n\nend\n\n"
    }, 
    "buildApi": {
        "micro": 0, 
        "major": 1, 
        "type": "APIVersion", 
        "minor": 10
    }, 
    "virtualSourceDefinition": {
        "status": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n-- virtual/status.lua\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"status\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_INSTALL_PATH=repository.mongoInstallPath,\n   MONGO_SHELL=repository.mongoShellPath,\n   MONGO_STATUS_TYPE=\"virtual\"\n}\n\nreturn RunBash {\n  command      = resources['status.sh'],\n  environment  = source.environment,\n  user         = source.environmentUser,\n  host         = source.host,\n  variables    = env,\n  outputSchema = { type = 'string' }\n}\n\n\n", 
        "configure": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\n-- snapshotJson passed to configure and reconfigure\n\nmyhostname = RunBash{\n   command     = resources[\"getHostname.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = {},\n   outputSchema = { type=\"string\" }\n}\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"configure\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_INSTALL_PATH=repository.mongoInstallPath,\n   MONGO_SHELL=repository.mongoShellPath,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_HOST=myhostname,\n   MONGO_ENABLE_KEYFILE=parameters.enableKeyAuth,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\nprovisionInfo = RunBash{\n   command     = resources[\"provision.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type=\"string\" }\n}\n\nif provisionInfo ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(provisionInfo)\n  Fail(errorMessage)\nend\n\nstartStatus = RunBash{\n   command     = resources[\"start.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type=\"string\" }\n}\n\nif startStatus ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(startStatus)\n  Fail(errorMessage)\nend\n\nuserStatus = RunBash{\n   command     = resources[\"createClusteradmin.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type=\"string\" }\n}\n\nif userStatus ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(userStatus)\n  Fail(errorMessage)\nend\n\nsourceConfigInfo = RunBash{\n   command     = resources[\"vdbsourceConfig.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         mongoHost = { type=\"string\" },\n         mongoPort = { type=\"integer\" },\n         dbPath = { type=\"string\" },\n         replicaSet = { type=\"string\" },\n         discoveryType = { type=\"string\" },\n         prettyName = { type=\"string\" }\n      }\n  }\n}\n\nreturn sourceConfigInfo\n", 
        "parameters": {
            "additionalProperties": false, 
            "ordering": [
                "mountPath", 
                "mongoPort", 
                "bindIP", 
                "oplogSize", 
                "journalInterval", 
                "mongoDBUser", 
                "mongoDBPassword", 
                "enableKeyAuth", 
                "keyfilePath"
            ], 
            "required": [
                "mountPath", 
                "bindIP", 
                "mongoPort", 
                "mongoDBUser", 
                "mongoDBPassword", 
                "enableKeyAuth"
            ], 
            "type": "object", 
            "properties": {
                "mountPath": {
                    "default": "", 
                    "prettyName": "Mount Path", 
                    "type": "string", 
                    "description": ""
                }, 
                "journalInterval": {
                    "default": 30, 
                    "environmentVariable": "MONGO_JOURNAL_FLUSH", 
                    "prettyName": "Journal Commit Interval (ms)", 
                    "type": "integer", 
                    "description": ""
                }, 
                "mongoPort": {
                    "default": 29000, 
                    "environmentVariable": "MONGO_PORT", 
                    "prettyName": "Port Number", 
                    "type": "integer", 
                    "description": ""
                }, 
                "mongoDBPassword": {
                    "default": "delphix", 
                    "prettyName": "MongoDB Password", 
                    "type": "string", 
                    "description": "If above user already exists, password will be updated.", 
                    "format": "password"
                }, 
                "oplogSize": {
                    "default": 1024, 
                    "environmentVariable": "MONGO_OPLOG_SIZE", 
                    "prettyName": "Oplog Size (MB)", 
                    "type": "integer", 
                    "description": ""
                }, 
                "mongoDBUser": {
                    "default": "clusteradmin", 
                    "prettyName": "MongoDB Clusteradmin User", 
                    "type": "string", 
                    "description": "This will be new user created on VDB"
                }, 
                "keyfilePath": {
                    "default": "", 
                    "prettyName": "KeyAuth Filename (Full Path)", 
                    "type": "string", 
                    "description": "KeyAuth Filename accessible on target host by target delphix environment o/s user [600 Permission]"
                }, 
                "enableKeyAuth": {
                    "default": "N", 
                    "prettyName": "Enable KeyAuth", 
                    "type": "string", 
                    "description": "", 
                    "enum": [
                        "Y", 
                        "N"
                    ]
                }, 
                "bindIP": {
                    "default": "0.0.0.0", 
                    "environmentVariable": "MONGO_BIND_IP", 
                    "prettyName": "bindIP String", 
                    "type": "string", 
                    "description": "CSV string of allowed IPs"
                }
            }
        }, 
        "stop": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"stop\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_INSTALL_PATH=repository.mongoInstallPath,\n   MONGO_SHELL=repository.mongoShellPath\n}\n\ndelphixOwned = RunBash{\n   command     = resources[\"checkOwnership.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = 'boolean' }\n}\n\nif delphixOwned then\n\tRunBash{\n   \t\tcommand     = resources[\"shutdown.sh\"],\n   \t\tenvironment = source.environment,\n   \t\tuser        = source.environmentUser,\n   \t\thost        = source.host,\n   \t\tvariables   = env\n\t}\nend\n", 
        "start": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"configure\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_INSTALL_PATH=repository.mongoInstallPath,\n   MONGO_SHELL=repository.mongoShellPath,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_HOST=myhostname,\n   MONGO_ENABLE_KEYFILE=parameters.enableKeyAuth,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\nRunBash{\n   command     = resources[\"start.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}", 
        "unconfigure": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"configure\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_INSTALL_PATH=repository.mongoInstallPath,\n   MONGO_SHELL=repository.mongoShellPath,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_HOST=myhostname,\n   MONGO_ENABLE_KEYFILE=parameters.enableKeyAuth,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\ndelphixOwned = RunBash{\n   command     = resources[\"checkOwnership.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = 'boolean' }\n}\n\nif delphixOwned then\n\tRunBash{\n   \t\tcommand     = resources[\"shutdown.sh\"],\n   \t\tenvironment = source.environment,\n   \t\tuser        = source.environmentUser,\n   \t\thost        = source.host,\n   \t\tvariables   = env\n\t}\nend", 
        "reconfigure": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\n-- snapshotJson passed to configure and reconfigure\n\nmyhostname = RunBash{\n   command     = resources[\"getHostname.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = {},\n   outputSchema = { type=\"string\" }\n}\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"configure\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_SNAPSHOT_METADATA=snapshotJson,\n   MONGO_INSTALL_PATH=repository.mongoInstallPath,\n   MONGO_SHELL=repository.mongoShellPath,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_HOST=myhostname,\n   MONGO_ENABLE_KEYFILE=parameters.enableKeyAuth,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\nprovisionInfo = RunBash{\n   command     = resources[\"provision.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type=\"string\" }\n}\n\nif provisionInfo ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(provisionInfo)\n  Fail(errorMessage)\nend\n\nstartStatus = RunBash{\n   command     = resources[\"start.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type=\"string\" }\n}\n\nif startStatus ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(startStatus)\n  Fail(errorMessage)\nend\n\nsourceConfigInfo = RunBash{\n   command     = resources[\"vdbsourceConfig.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         mongoHost = { type=\"string\" },\n         mongoPort = { type=\"integer\" },\n         dbPath = { type=\"string\" },\n         replicaSet = { type=\"string\" },\n         mongoDBUser = { type=\"string\" },\n         mongoDBPassword = { type=\"string\" },\n         discoveryType = { type=\"string\" },\n         prettyName = { type=\"string\" }\n      }\n  }\n}\n\nreturn sourceConfigInfo\n", 
        "preSnapshot": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\nmyhostname = RunBash{\n   command     = resources[\"getHostname.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = {},\n   outputSchema = { type=\"string\" }\n}\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"preSnapshot\",\n   MONGO_INSTALL_PATH = repository.mongoInstallPath,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_SHELL = repository.mongoShellPath,\n   MONGO_HOST=myhostname,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword\n}\n\noutput = RunBash{\n   command     = resources[\"fsyncLock.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n\nif output ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(output)\n  Fail(errorMessage)\nend\n\nRunBash{\n   command     = resources[\"saveKeyFile.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env\n}\n\noutput = RunBash{\n   command     = resources[\"vdbupdateconfigfile.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n", 
        "mountSpec": "--\r\n-- Copyright (c) 2015 by Delphix. All rights reserved.\r\n--\r\n\r\nmounts = {}\r\n\r\ntargetMountPath = parameters.mountPath\r\n\r\nmountIndex = 1\r\n\r\n-- Mount primary node\r\nmounts[mountIndex] = {\r\n    environment = source.environment,\r\n    mountPath = targetMountPath\r\n}\r\n\r\nreturn mounts", 
        "type": "ToolkitVirtualSource", 
        "postSnapshot": "--\n-- Copyright (c) 2016 by Delphix. All rights reserved.\n--\n\nmyhostname = RunBash{\n   command     = resources[\"getHostname.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = {},\n   outputSchema = { type=\"string\" }\n}\n\nenv = {\n   DLPX_DATA_DIRECTORY=parameters.mountPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_TOOLKIT_WORKFLOW=\"postSnapshot\",\n   MONGO_BIND_IP=parameters.bindIP,\n   MONGO_JOURNAL_FLUSH=parameters.journalInterval,\n   MONGO_KEYFILE_PATH=parameters.keyfilePath,\n   MONGO_OPLOG_SIZE=parameters.oplogSize,\n   MONGO_HOST=myhostname,\n   MONGO_PORT=parameters.mongoPort,\n   MONGO_STORAGE_ENGINE=parameters.storageEngine,\n   MONGO_INSTALL_PATH = repository.mongoInstallPath,\n   MONGO_SHELL = repository.mongoShellPath,\n   MONGO_USER_NAME=parameters.mongoDBUser,\n   MONGO_USER_PASSWORD=parameters.mongoDBPassword,\n   MONGO_STAGING_SERVER_BOOL=false\n}\n\noutput = RunBash{\n   command     = resources[\"fsyncUnlock.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {type = \"string\"}\n}\n\nif output ~= \"SUCCESS\" then\n  errorMessage = messages.errormessage(output)\n  Fail(errorMessage)\nend\n\nreturn RunBash{\n   command     = resources[\"vdbrecordStatus.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         toolkitVersion = { type=\"string\" },\n         timestamp = { type=\"string\" },\n         architecture = { type=\"string\" },\n         osType = { type=\"string\" },\n         osVersion = { type=\"string\" },\n         mongoVersion = { type=\"string\" },\n         delphixMount = { type=\"string\" },\n         mongoPort = { type=\"integer\" },\n         storageEngine = { type=\"string\" },\n         mongoAuth = { type=\"string\" },\n         replicaSet = { type=\"string\" },\n         journalInterval = { type=\"integer\" },\n         oplogSize = { type=\"integer\" },\n         mongoDBUser  = { type=\"string\" },\n         mongoDBPassword  = { type=\"string\" },\n         dSourceType  = { type=\"string\" },\n         appenddbPath  = { type=\"string\" }\n      }\n   }\n}"
    }, 
    "messages": [
        {
            "localeName": "en-us", 
            "type": "ToolkitLocale", 
            "messages": {
                "doubleerror": "Double error {0} and {1} found.", 
                "errormessage": "{0}", 
                "singleerror": "Single error {0} found."
            }
        }
    ], 
    "hostTypes": [
        "UNIX"
    ], 
    "version": "4.2.0", 
    "upgradeDefinition": {
        "upgradeLinkedSource": "return parameters\n", 
        "upgradeManualSourceConfig": "return parameters\n", 
        "upgradeSnapshot": "snapshot.toolkitVersion = \"4.2\"\nsnapshot.dSourceType=\"emptyStagingFS\"\nsnapshot.appenddbPath=\"N/A\"\nreturn snapshot\n", 
        "upgradeVirtualSource": "return parameters\n", 
        "type": "ToolkitUpgradeDefinition", 
        "fromVersion": "4.1.0"
    }, 
    "defaultLocale": "en-us", 
    "prettyName": "MongoDB", 
    "type": "Toolkit", 
    "resources": {
        "initiateStagingFS.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n\n# Program Name ...\nPGM_NAME=\"initiateStagingFS.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\n\necho \"IGNORE dsPreSnapshot scripts\" > ${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0", 
        "addStagingToPrimary.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n\n# Program Name ...\nPGM_NAME=\"addStagingToPrimary.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\nlog \"MONGO_REPLICASET=$MONGO_REPLICASET\"\n\n# Grab the primary replication port and host\nprimaryReplica=$(findPrimaryReplica ${MONGO_REPLICASET} ${MONGO_SRC_HOST} ${MONGO_SRC_PORT})\nlog \"Primary Replica : $primaryReplica\"\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\n#For MongodDB  <= 2.8, need to specify an unused _id value in the replica set\nlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \\\"printjson(JSON.stringify(rs.status()))\\\"\"\nreplicationStatus=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\n#replicationMembers=$(echo $replicationStatus| jq -r '.members|.[]|.name')\nreplicationMembers=$(echo $replicationStatus| jq -r '.members|.[]|(\"{\\\"_id\\\": \\\"\" + (._id|tostring) + \"\\\", \\\"name\\\": \\\"\" + .name + \"\\\", \\\"state\\\": \\\"\" + (.state|tostring) + \"\\\", \\\"stateStr\\\": \\\"\" + .stateStr + \"\\\"}\")')\n#echo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n#log \"replicationMembers:\"\n#log \"$replicationMembers\"\n#echo \"`echo $replicationConfig|python -m json.tool`\" >> $DEBUG_LOG\n#echo \"$replicationConfig\" >> $DEBUG_LOG\n#echo \"============================================================================================================================================================\"  >> $DEBUG_LOG\ncat_variable \"$replicationMembers\"\n\n\nreplicationConfig=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.conf())\")\n#_id An integer identifier of every member in the replica set. Values must be between 1 and 255 inclusive.\n#see https://docs.mongodb.org/manual/reference/replica-configuration/#rsconf.members[n]._id\nfor i in {0..255}; do\n    member=$(echo \"$replicationConfig\" | jq -r \".members | .[] | select(._id == $i)\")\n    if [ -z \"$member\" ]; then\n        new_id=$i\n\t\tprev_id=$(( $i - 1 ))\n\t\tprev_hostandport=$(echo \"$replicationConfig\" | jq \".members | .[] | select(._id == $prev_id)|.host\"|sed -e 's/\"//g')\n\t\tprev_host=`echo $prev_hostandport|awk -F: '{ print $1}'`\n\t\tprev_port=`echo $prev_hostandport|awk -F: '{ print $2}'`\n\t\tif [ $DLPX_TOOLKIT_WORKFLOW = \"resync\" ]; then\n\t\t\tif [ $prev_host = $MONGO_HOST ] && [ $prev_port = $MONGO_PORT ]; then\n\t\t\t\tlog \"There is stale configuration with host = $prev_host and port = $prev_port in configuration[rs.conf()]. Please remove before you proceed.\"\n\t\t\t\techo \"\\\"ASTP1000 : There is stale configuration with host = $prev_host and port = $prev_port in configuration[rs.conf()]. Please remove before you proceed.\\\"\" > $DLPX_OUTPUT_FILE\n\t\t\t\tlog \"Please validate and execute:\"\n\t\t\t\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\t\t\t\techo \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \\\"rs.remove(\\\\\\\"$MONGO_HOST:$MONGO_PORT\\\\\\\")\\\"\" >> $DEBUG_LOG\n\t\t\t\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\t\t\t\texit 0;\n\t\t\tfi\n\t\tfi\n\t\tlog \"New ID for staging instance on $MONGO_PORT : $new_id\"\n\t\tbreak\n    else\n        log \"Member Id $i : Already Exists.\"\n    fi\ndone\n\nif [ -z \"$new_id\" ]; then\n    die \"no valid ids available in replica set\"\nfi\n\nlog \"Adding Delphix staging host $MONGO_HOST:${MONGO_PORT} to replica set with _id=$new_id\"\nlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(rs.add({host:'${MONGO_HOST}:${MONGO_PORT}', priority: 0, votes: 0, hidden: true, _id: $new_id}))\\\"\"\n\noutput=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.add({host:'${MONGO_HOST}:${MONGO_PORT}', priority: 0, votes: 0, hidden: true, _id: $new_id}))\")\n#echo \"`echo $output|python -m json.tool`\" >> $DEBUG_LOG\nsuccess=$(echo \"$output\" | jq '.ok')\n#Code 103 = Found two member configurations with same host field, meaning staging server already added\nif [ $success -eq 0 ]\nthen\n    code=$(echo \"$output\" | jq '.code')\n    errmsg=$(echo \"$output\" | jq '.errmsg')\n    log \"Failed : rs.add({host:\\'$MONGO_HOST:${MONGO_PORT}\\', priority: 0, votes: 0, hidden: true, _id: $new_id})\"\n\tlog \"ASTP1001 : rs.add failed: Code: $code error:  $errmsg.\"\n\techo \"\\\"ASTP1001 : rs.add failed: Code: $code error:  $errmsg.\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\n    #die \"rs.add failed: Code: $code error:  $errmsg\"\nelse\n    log \"Success : rs.add({host:\\'$MONGO_HOST:${MONGO_PORT}\\', priority: 0, votes: 0, hidden: true, _id: $new_id})\"\nfi\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "initiate.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"initiate.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\ngetSystemInfo\n\nif [[ -z $MONGO_REPLICASET ]]; then\n        getConfigValue \"MONGO_REPLICASET\" \"MONGO_REPLICASET\"\nfi\n\noutput=$($MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.initiate())\")\n\nlog \"rs.initiate output: $output\"\n\nconfig=\"{_id: '$MONGO_REPLICASET', members:[{_id: 0, host: 'localhost:$MONGO_PORT'}]}\"\n\nlog \"Updating replicaset config with $config\"\n\noutput=$($MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.reconfig(${config}, {force: true}))\")\n\nlog \"mongo 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(rs.reconfig(${config}, {force: true}))\\\"\"\n\nlog \"rs.reconfig output: $output\"\n\nexit 0\n", 
        "getStagingConfig.lua": "--\n-- Copyright (c) 2015, 2016 by Delphix. All rights reserved.\n--\n\n-- lua_name=\"resync\"\nlua_name=env.DLPX_TOOLKIT_WORKFLOW\nif config.discoveryType == \"Auto\" then\n    env = {\n       DLPX_TOOLKIT_WORKFLOW=lua_name,\n       DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n    }\n\n    repoConfigfile = RunBash{\n       command     = resources[\"getMongoRepoCfgFile.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {type = \"string\"}\n    }\n\n    if repoConfigfile == \"SKIP_MANUALREPODISCOVERY\" then\n        repoConfigfile = 'ManualRepoDiscoveryFileNotProvided'\n    end\n\n    env.DLPX_REPO_CFGFILE=repoConfigfile\n    env.MONGO_VERSION=repository.version\n\n    stagingConfig = RunBash{\n       command     = resources[\"getStagingConfig.sh\"],\n       environment = source.stagingEnvironment,\n       user        = source.stagingEnvironmentUser,\n       host        = source.stagingHost,\n       variables   = env,\n       outputSchema = {\n        type = \"object\",\n        additionalProperties = false,\n        properties = {\n          mongoInstallPath = { type=\"string\" },\n          mongoShellPath   = { type=\"string\" },\n          version          = { type=\"string\" }\n        }\n       }\n    }\n    \n    mongo_install_path = stagingConfig.mongoInstallPath\n    mongo_shell = stagingConfig.mongoShellPath\n\nelseif config.discoveryType == \"Manual\" then\n    mongo_install_path = repository.mongoInstallPath\n    mongo_shell = repository.mongoShellPath\nelse\n    errorMessage = messages.errormessage(\"Not able to find staging repository\")\n    Fail(errorMessage)\nend\n", 
        "start.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\nset -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"start.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\ngetSystemInfo\ngetConfigValue \"MONGO_STORAGE_ENGINE\" \"MONGO_STORAGE_ENGINE\"\n#getConfigValue \"MONGO_REPLICASET\" \"MONGO_REPLICASET\"\n\nCFG_FILE=${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\nlog \"CFG_FILE = $CFG_FILE\"\ncat_file $CFG_FILE\nMONGO_DSOURCE_TYPE=$(cat $CFG_FILE|grep \"MONGO_DSOURCE_TYPE\" | awk -F'=' '{ print $2}')\nMONGO_APPEND_DBPATH=$(cat $CFG_FILE|grep \"MONGO_APPEND_DBPATH\" | awk -F'=' '{ print $2}')\n\nlog \"MONGO_DSOURCE_TYPE = $MONGO_DSOURCE_TYPE\"\nlog \"MONGO_APPEND_DBPATH = $MONGO_APPEND_DBPATH\"\nif [ $MONGO_DSOURCE_TYPE = \"emptyStagingFS\" ]; then\n\tDATA_DIRECTORY=$DLPX_DATA_DIRECTORY/$MONGO_APPEND_DBPATH\nelse\n\tDATA_DIRECTORY=$DLPX_DATA_DIRECTORY\nfi\nlog \"DATA_DIRECTORY = $DLPX_DATA_DIRECTORY\"\t\n\n# Construct base command\nmongoCommand=\"$MONGO_INSTALL_PATH --logpath ${DLPX_DATA_DIRECTORY}/mongod.log --fork --dbpath $DATA_DIRECTORY --journal --journalCommitInterval $MONGO_JOURNAL_FLUSH --oplogSize $MONGO_OPLOG_SIZE --port $MONGO_PORT\"\n\nkeyFileName=${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\n# If there is keyfile auth then enable it from the known keyfile location\nif [[ -f $keyFileName ]]; then\n\tlog \"keyFileName = $keyFileName\"\n\tlog \"`ls -l $keyFileName`\"\n\tmongoCommand=\"$mongoCommand --keyFile $keyFileName\"\nelse\n\tlog \"keyFileName not found.\"\nfi\n\n# If storage engine is anything but mmap we need to add it explicitly. This is because --storageEngine is not a valid param for 2.6\nif [[ ! -z $MONGO_STORAGE_ENGINE ]] && [[ \"$MONGO_STORAGE_ENGINE\" != \"mmapv1\" ]]; then\n\tmongoCommand=\"$mongoCommand --storageEngine $MONGO_STORAGE_ENGINE\"\nfi\n\n# Add bind ip if specified\nif [[ ! -z \"MONGO_BIND_IP\" ]]; then\n    mongoCommand=\"$mongoCommand --bind_ip $MONGO_BIND_IP\"\nfi\n\nlog \"Starting Mongo VDB:\\n$mongoCommand\"\noutput=$($mongoCommand)\nlog \"Result:\\n$output\"\n\n#sleep 20\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\n\nexit 0\n", 
        "getMongoRepoCfgFile.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#\n# Program Name ...\n#\nPGM_NAME=\"getMongoRepoCfgFile.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\n\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\n. $HOME/.setDelphixMongoEnv\nif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\tlog \"MONGO_REPO_CFGFILE=$MONGO_REPO_CFGFILE\"\nfi\n\nif [ -z \"$MONGO_REPO_CFGFILE\" ]; then\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"Env variable MONGO_REPO_CFGFILE not defined.\"\n\t\tlog \"Manual/Custom repo Discovery disabled\"\n\tfi\n\techo \"\\\"SKIP_MANUALREPODISCOVERY\\\"\" > $DLPX_OUTPUT_FILE\nelse\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"Manual/Custom repo Discovery enabled\"\n\tfi\n\techo \"\\\"$MONGO_REPO_CFGFILE\\\"\" > $DLPX_OUTPUT_FILE\nfi\n\nexit 0\n", 
        "mongoseedinstance.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n#DLPX_TOOLKIT_WORKFLOW='resync.lua'\n#DLPX_LIBRARY_SOURCE=`cat /home/delphix/bkp/library.sh`\n#MONGO_PORT=27310\n#DLPX_DATA_DIRECTORY=/mnt/provision/mongovdb1\n#MONGO_INSTALL_PATH=/u01/mongodb/mongoDB409/bin/mongod\n#MONGO_SHELL=/u01/mongodb/mongoDB409/bin/mongo\n#DLPX_OUTPUT_FILE=$DLPX_DATA_DIRECTORY/output.log\n\n# Program Name ...\nPGM_NAME=\"mongoseedinstance.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\n\nlog \"Generating seed database config file\"\ncat << EOF > $DLPX_DATA_DIRECTORY/mongod${MONGO_PORT}.conf\n# where to write logging data.\nsystemLog:\n  destination: file\n  logAppend: true\n  path: $DLPX_DATA_DIRECTORY/mongod.log\n\n# Where and how to store data.\nstorage:\n  dbPath: $DLPX_DATA_DIRECTORY\n  journal:\n    enabled: true\n\n# how the process runs\nprocessManagement:\n  fork: true  # fork and run in background\n  pidFilePath: $DLPX_DATA_DIRECTORY/mongod.pid  # location of pidfile\n  timeZoneInfo: /usr/share/zoneinfo\n\n# network interfaces\nnet:\n  port: $MONGO_PORT\n  bindIp: 0.0.0.0  # Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.\n\nEOF\n\nerrorChecktReturn \"Unable to generate seed database config file\"\nlog \"Generated seed database config file\"\n\n# Create directory for oplogs and logs\nlog \"Creating logs and oplogs directory\"\nmkdir $DLPX_DATA_DIRECTORY/logs $DLPX_DATA_DIRECTORY/oplogs\nerrorChecktReturn \"Unable to create logs and oplogs directory\"\nlog \"Created logs and oplogs directory\"\n\nlog \"Starting staging seed mongo instance on port $MONGO_PORT\"\n$MONGO_INSTALL_PATH -f $DLPX_DATA_DIRECTORY/mongod${MONGO_PORT}.conf\nerrorChecktReturn \"Unable to start staging seed mongo instance on port $MONGO_PORT\"\nlog \"Started mongo instance on port $MONGO_PORT\"\n\nlog \"Create clusteradmin user...\"\nlog \"$MONGO_SHELL admin --host 127.0.0.1:$MONGO_PORT --quiet --eval \\\"db.createUser({user: \\\"$MONGO_USER_NAME\\\",pwd: \\\"$MONGO_USER_PASSWORD\\\", roles: [\\\"userAdminAnyDatabase\\\", \\\"dbAdminAnyDatabase\\\", \\\"readWriteAnyDatabase\\\" ,\\\"clusterAdmin\\\"]})\\\"\"\n$MONGO_SHELL admin --host 127.0.0.1:$MONGO_PORT --quiet --eval \"db.createUser({user: \\\"$MONGO_USER_NAME\\\",pwd: \\\"$MONGO_USER_PASSWORD\\\", roles: [\\\"userAdminAnyDatabase\\\", \\\"dbAdminAnyDatabase\\\", \\\"readWriteAnyDatabase\\\" ,\\\"clusterAdmin\\\"]})\"\n#errorChecktReturn \"Unable to create clusteradmin user\"\nlog \"Created clusteradmin user\"\n\nlog \"Create directory $DLPX_DATA_DIRECTORY/.delphix\"\nmkdir $DLPX_DATA_DIRECTORY/.delphix\nlog \"Created directory\"\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "updateconfigfile.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Program Name ...\n#\nPGM_NAME=\"updateconfigfile.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\ngetSystemInfo\n\n# setting default to mmap as 2.6 does not have a value\nif [[ -z \"$MONGO_STORAGE_ENGINE\" ]]; then\n    MONGO_STORAGE_ENGINE='mmapv1'\nfi\n\n#MONGO_KEYFILE_PATH is set in paramaters for staging. This value is not available on refresh or rewind, so in that case we grep the mongod process to identify whether the keyfile is set or not.\nif [[ $MONGO_STAGING_SERVER_BOOL = true ]]; then\n    if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n        MONGO_AUTH='keyfile'\n    fi\nfi\n\nlog \"MONGO_DSOURCE_TYPE = $MONGO_DSOURCE_TYPE\"\nif [ $MONGO_DSOURCE_TYPE = \"emptyStagingFS\" ]; then\n\tNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\n\tif [ -f $NEWDSOURCEFILE ]; then\n\t\tlog \"File $NEWDSOURCEFILE exists. This is initial staging instance provisioning\"\n\t\tMONGO_DBPATH=\"N/A\"\n\t\tMONGO_APPEND_DBPATH=\"N/A\"\n\telse\n\t\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ****** -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \\\"db.serverCmdLineOpts().parsed.storage.dbPath\\\"\"\n\t\tMONGO_DBPATH=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \"db.serverCmdLineOpts().parsed.storage.dbPath\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tlog \"Unable to pull dbPath\"\n\t\t\tMONGO_DBPATH=\"ERROR\"\n\t\t\tMONGO_APPEND_DBPATH=\"ERROR\"\n\t\telse\n\t\t\tMONGO_APPEND_DBPATH=$(basename $MONGO_DBPATH)\n\t\tfi\n\tfi\nelse\n\tMONGO_DBPATH=\"N/A\"\n\tMONGO_APPEND_DBPATH=\"N/A\"\nfi\n\noutput_string=$(printf \"MONGO_STORAGE_ENGINE: $MONGO_STORAGE_ENGINE\")\noutput_string=$(printf \"${output_string}\\nMONGO_AUTH: $MONGO_AUTH\")\noutput_string=$(printf \"${output_string}\\nMONGO_REPLICASET: $MONGO_REPLICASET\")\necho \"$output_string\" >${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nsed -i '/MONGO_DSOURCE_TYPE/ d' ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\necho \"MONGO_DSOURCE_TYPE=$MONGO_DSOURCE_TYPE\" >> ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nsed -i '/MONGO_DBPATH/ d' ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\necho \"MONGO_DBPATH=$MONGO_DBPATH\" >> ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nsed -i '/MONGO_APPEND_DBPATH/ d' ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\necho \"MONGO_APPEND_DBPATH=$MONGO_APPEND_DBPATH\" >> ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\ncat_file ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "library.sh": "# Copyright (c) 2018 by Delphix. All rights reserved.\n# library.sh\n# Library of common mongo toolkit functions ... \n\n# Delphix Supplied Environment Variables ...\n# DLPX_BIN_JQ=`which jq`\n# DLPX_DATA_DIRECTORY\n\n## Globals\nTOOLKIT_VERSION=\"4.2.0\"\nDLPX_TOOLKIT_NAME=\"mongo\"\nDLPX_LOG_DIRECTORY=\"/tmp\"               # =\"${DLPX_DATA_DIRECTORY}/..\"\n\nTIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)\nCONFIG_OUTPUT_FILE=\"delphix_${DLPX_TOOLKIT_NAME}_config.dat\"\nERROR_LOG=\"${DLPX_LOG_DIRECTORY}/delphix_${DLPX_TOOLKIT_NAME}_error.log\"\nDEBUG_LOG=\"${DLPX_LOG_DIRECTORY}/delphix_${DLPX_TOOLKIT_NAME}_debug.log\"\n\nif [ $DLPX_TOOLKIT_WORKFLOW != \"repositoryDiscovery\" ]; then\n\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\techo \"Workflow : $DLPX_TOOLKIT_WORKFLOW - $PGM_NAME\" >> $DEBUG_LOG\n\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\nfi\nlog \"Mongo Toolkit Version : $TOOLKIT_VERSION\"\n\n## Functions ...\n# Log infomation and die if option -d is used.\nfunction log {\n   Parms=$@\n   die='no'\n   if [[ $1 = '-d' ]]; then\n\t  shift\n\t  die='yes'\n\t  Parms=$@\n   fi\n   printf \"[${TIMESTAMP}][DEBUG][%s][%s]:[$Parms]\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME\n   printf \"[${TIMESTAMP}][DEBUG][%s][%s]:[$Parms]\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME >>$DEBUG_LOG\n   if [[ $die = 'yes' ]]; then\n\t  exit 2\n   fi\n}\n\n# Log error and write to the errorlog\nfunction errorLog {\n   log \"$@\"\n   echo -e \"[${TIMESTAMP}][ERROR][$@]\" >>$ERROR_LOG\n}\n\n# Write to log and errorlog before exiting with an error code\nfunction die {\n   errorLog \"$@\"\n   exit 2\n}\n\n# Function to check for errors and die with passed in error message\nfunction errorCheck {\n   if [ $? -ne 0 ]; then\n\t  die \"$@\"\n   fi\n}\n\n# Function to check for errors and die with passed in error message\nfunction errorChecktReturn {\n   if [ $? -ne 0 ]; then\n\t  errorLog \"$@\"\n\t  log \"$@. Please check $DEBUG_LOG and $ERROR_LOG for more details.\"\n\t  echo \"\\\"$@\\\"\" > $DLPX_OUTPUT_FILE\n\t  exit 0\n   fi\n}\n\n# Function to collect system info ARCH, OSTYPE, OSVERSION, MONGO_VERSION\nfunction getSystemInfo {\n\tlog \"getSystemInfo: Getting system info\"\n\tARCH=$(uname -p)\n\tOSTYPE=$(uname)\n\tif [ \"$OSTYPE\" = \"SunOS\" ]; then\n\t\tOSTYPE=\"Solaris\"\n\t\tOSVERSION=$(uname -v)\n\t\tOSSTR=\"$OSTYPE ${REV}(${ARCH} `uname -v`)\"\n\telif [ \"$OSTYPE\" = \"AIX\" ]; then\n\t\tOSSTR=\"$OSTYPE `oslevel` (`oslevel -r`)\"\n\t\tOSVERSION=$(oslevel)\n\telif [ \"$OSTYPE\" = \"Linux\" ]; then\n\t\tif [ -f /etc/redhat-release ]; then\n\t\t\tOSTYPE=RedHat\n\t\t\tOSVERSION=$(cat /etc/redhat-release | sed 's/.*release\\ //' | sed 's/\\ .*//')\n\t\telse\n\t\t\tdie \"Unsupported Linux Distro\"\n\t\t\tOSTYPE=Unknown\n\t\t\tOSVERSION=Unsupported\n\t\tfi\n\tfi\n\t# Get Mongo version\n\tMONGO_VERSION=$($MONGO_INSTALL_PATH --version | grep \"db version\" | awk '{print $3}')\n\tMONGO_STORAGE_ENGINE=\n}\n\n# Confirm that JQ is available on this system and add it to path\nfunction initializeJQ {\n\t# Add jq to PATH for convenience. Note that it is appended to the front so we\n\t# will always use it even if jq is installed elsewhere on the machine\n\tPATH=\"$(dirname \"$DLPX_BIN_JQ\"):${PATH}\"\n\n\t# Confirm that invoking jq works properly\n\tjq '.' <<< '{}' >/dev/null 2>/dev/null\n\terrorCheck 'Unable to initialize JQ'\n}\n\n\n# Quotes strings for use with JSON. Fails if the number of arguments is not\n# exactly one because it will not do what the user likely expects.\nfunction jqQuote {\n   if [[ \"$#\" -ne 1 ]]; then\n\t  log -d \"Wrong number of arguments to jqQuote: $@\"\n   fi\n   $DLPX_BIN_JQ -R '.' <<< \"$1\"\n}\n\n#function purgeLogs {\n#   MaxFileSize=20971520\n#   DT=`date '+%Y%m%d%H%M%S'`\n#   log \"Checking Log File Sizes ... \"\n#   #\n#   # Debug Log \n#   #\n#   if [ -f $DEBUG_LOG ]; then\n#\t   file_size=`du -b ${DEBUG_LOG} | tr -s '\\t' ' ' | cut -d' ' -f1`\n#\t   if [ $file_size -gt $MaxFileSize ];then   \n#\t\t  mv ${DEBUG_LOG} ${DEBUG_LOG}_${DT}\n#\t\t  touch ${DEBUG_LOG}\n#\t   fi\n#   fi\n#   #\n#   # Error Log \n#   #\n#   if [ -f $ERROR_LOG ]; then\n#\t   file_size=`du -b ${ERROR_LOG} | tr -s '\\t' ' ' | cut -d' ' -f1`\n#\t   if [ $file_size -gt $MaxFileSize ];then\n#\t\t  mv ${ERROR_LOG} ${ERROR_LOG}_${DT}\n#\t\t  touch ${ERROR_LOG}\n#\t   fi\n#   fi\n#}\n\nfunction purgeLogs {\n   #log \"Checking Log File Sizes ... \"\n   # Once the log files exceed 20000 rows remove the first 20000 of them.\n   lines=$(wc -l $DEBUG_LOG)\n   if [[ $? -eq 0 ]]; then\n\t  lines=$(echo $lines | awk '{print $1}')\n\t  if [[ $lines -gt 20000 ]]; then\n\t\t if [ -f ${DEBUG_LOG}.9 ]; then\n\t\t\tmv ${DEBUG_LOG}.9 ${DEBUG_LOG}.10\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.8 ]; then\n\t\t\tmv ${DEBUG_LOG}.8 ${DEBUG_LOG}.9\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.7 ]; then\n\t\t\tmv ${DEBUG_LOG}.7 ${DEBUG_LOG}.8\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.6 ]; then\n\t\t\tmv ${DEBUG_LOG}.6 ${DEBUG_LOG}.7\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.5 ]; then\n\t\t\tmv ${DEBUG_LOG}.5 ${DEBUG_LOG}.6\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.4 ]; then\n\t\t\tmv ${DEBUG_LOG}.4 ${DEBUG_LOG}.5\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.3 ]; then\n\t\t\tmv ${DEBUG_LOG}.3 ${DEBUG_LOG}.4\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.2 ]; then\n\t\t\tmv ${DEBUG_LOG}.2 ${DEBUG_LOG}.3\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.1 ]; then\n\t\t\tmv ${DEBUG_LOG}.1 ${DEBUG_LOG}.2\n\t\t fi\n\t\t if [ -f ${DEBUG_LOG}.0 ]; then\n\t\t\tmv ${DEBUG_LOG}.0 ${DEBUG_LOG}.1\n\t\t fi\n\t\t cp $DEBUG_LOG ${DEBUG_LOG}.0\n\t\t cat /dev/null > $DEBUG_LOG\n\t  fi\n   fi\n   lines=$(wc -l $ERROR_LOG)\n   if [[ $? -eq 0 ]]; then\n\t  lines=$(echo $lines | awk '{print $1}')\n\t  if [[ $lines -gt 20000 ]]; then\n\t\t if [ -f ${ERROR_LOG}.9 ]; then\n\t\t\tmv ${ERROR_LOG}.9 ${ERROR_LOG}.10\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.8 ]; then\n\t\t\tmv ${ERROR_LOG}.8 ${ERROR_LOG}.9\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.7 ]; then\n\t\t\tmv ${ERROR_LOG}.7 ${ERROR_LOG}.8\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.6 ]; then\n\t\t\tmv ${ERROR_LOG}.6 ${ERROR_LOG}.7\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.5 ]; then\n\t\t\tmv ${ERROR_LOG}.5 ${ERROR_LOG}.6\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.4 ]; then\n\t\t\tmv ${ERROR_LOG}.4 ${ERROR_LOG}.5\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.3 ]; then\n\t\t\tmv ${ERROR_LOG}.3 ${ERROR_LOG}.4\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.2 ]; then\n\t\t\tmv ${ERROR_LOG}.2 ${ERROR_LOG}.3\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.1 ]; then\n\t\t\tmv ${ERROR_LOG}.1 ${ERROR_LOG}.2\n\t\t fi\n\t\t if [ -f ${ERROR_LOG}.0 ]; then\n\t\t\tmv ${ERROR_LOG}.0 ${ERROR_LOG}.1\n\t\t fi\n\t\t cp $ERROR_LOG ${ERROR_LOG}.0\n\t\t cat /dev/null > $ERROR_LOG\n\t  fi\n   fi\n}\n\n# Keep for Library Verification ...\nfunction hey {\n   echo \"there\"\n}\n\n# Function that returns 0 if the replica is in a healthy state\nfunction checkReplicationStatus {\n\tlocal json\n\tlocal mongo_state\n\tlocal repMembers\n\tlog \"checkReplicationStatus : Checking Status\"\n\t# Get replicaset status\n\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(rs.status())\\\"\"\n\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\tjson=$($MONGO_SHELL -u \"$MONGO_USER_NAME\" -p \"$MONGO_USER_PASSWORD\" --host \"$MONGO_HOST\" --port \"$MONGO_PORT\" --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\n\n\t#echo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\tlog \"rs.status:\"\n\trepMembers=$(echo $json| jq -r '.members|.[]|(\"{\\\"_id\\\": \\\"\" + (._id|tostring) + \"\\\", \\\"name\\\": \\\"\" + .name + \"\\\", \\\"state\\\": \\\"\" + (.state|tostring) + \"\\\", \\\"stateStr\\\": \\\"\" + .stateStr + \"\\\"}\")')\n\tcat_variable \"$repMembers\"\n\t#echo \"`echo $json|python -m json.tool`\" >> $DEBUG_LOG\n\t#echo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\n\t# Get hostname - need this to lookup the member status\n\thostname=$(hostname)\n\t# We are intentionally supressing errors at .[] so that JQ does not throw an additional error when rs.status fails\n\tmongo_state=$(echo \"$json\" | jq \".members | .[]? | select(.self == true) | .state\")\n\terrorLog \"checkReplicationStatus warning: Unable to check Mongo status\"\n\tif [[ mongo_state -ne 2 ]]; then\n\t\terrorLog \"checkReplicationStatus warning: Mongo in invalid state ($mongo_state)\"\n\t\treturn 1\n\tfi\n\tlog \"checkReplicationStatus: Replication status is good\"\n\treturn 0\n}\n\n\n# Search for the value of the search_term in the delphixMongoConfig.dat file\n# If value is found it is stored in the response_variable_name variable, if not\n# the function dies with error\n# Input params: config term (eg: TOOLKIT_VERSION, DB2VERSION, etc...) and\n# response_variable_name\nfunction getConfigValue {\n\tlog \"getConfigValue: Getting Config Value --> $search_term\"\n\tif [ \"$#\" -ne 2 ]; then\n\t\t\tdie \"Mongo Config Error: Incorrect params to getConfigValue($@). Expecting search_term and response_variable_name\"\n\tfi\n\tlocal search_term=\"$1\"\n\tlocal response_variable_name=\"$2\"\n\tif [ -z \"$search_term\" ]; then\n\t\t\tdie \"Mongo Config Error: Empty search param for getConfigValue()\"\n\tfi\n\tif [ -z \"$response_variable_name\" ]; then\n\t\t\tdie \"Mongo Config Error: Empty response variable param for getConfigValue()\"\n\tfi\n\tlocal response_value=$(grep -F \"$search_term\" $DLPX_DATA_DIRECTORY/$CONFIG_OUTPUT_FILE | awk 'NF>1{print $NF}')\n\terrorCheck \"Mongo Config Error: Unable to find config value for $search_term\"\n\tif [ -z \"$response_value\" ]; then\n\t\t\tdie \"Mongo Config Error: Unable to find config value for $search_term\"\n\tfi\n\t# Set the named response variable to the appropriate value\n\teval $response_variable_name=\\$response_value\n}\n\n# Confirm that the value of the config param on the current host matches the\n# snapshot\n# Input params: config term and current value\nfunction confirmConfigValue {\n\tlog \"confirmConfigValue: Confirming Config Value --> Search:$1 Current:$2\"\n\tif [ \"$#\" -ne 2 ]; then\n\t\t\tdie \"Mongo Config Error: Incorrect params to confirmConfigValue($@)\"\n\tfi\n\tlocal search_term=\"$1\"\n\tlocal current_value=\"$2\"\n\tif [ -z \"$search_term\" ]; then\n\t\t\tdie \"Mongo Config Error: Empty search_term for confirmConfigValue()\"\n\tfi\n\tif [ -z \"$current_value\" ]; then\n\t\t\tdie \"Mongo Config Error: Empty current_value for confirmConfigValue()\"\n\tfi\n\t# Store the snapshot value of the config in a temp variable\n\tgetConfigValue \"$search_term\" \"temp_variable\"\n\t# Compare current value of the term against the temp_variable\n\tif [ \"$current_value\" != \"$temp_variable\" ]; then\n\t\t\tdie \"Mongo Config Error: $search_term of snapshot ($temp_variable) does not match this server ($current_value)\"\n\tfi\n}\n\n# Search for the value of the search_term in the snapshotJson metadata\n# If value is found it is stored in the response_variable_name variable, if not\n# the function dies with error\n# Input params: config term (eg: toolkitVersion, MongoVersion, etc...) and\n# response_variable_name\nfunction getSnapshotValue {\n\tlog \"getSnapshotValue: Getting Snapshot Value --> Search:$1 Response:$2\"\n\tif [[ \"$#\" -ne 2 ]]; then\n\t\t\tlog -d \"Mongo Config Error: Incorrect params to getConfigValue($@). Expecting search_term and response_variable_name\"\n\tfi\n\tlocal search_term=\"$1\"\n\tlocal response_variable_name=\"$2\"\n\tif [[ -z \"$search_term\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: Empty search param for getConfigValue()\"\n\tfi\n\tif [[ -z \"$response_variable_name\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: Empty response variable param for getConfigValue()\"\n\tfi\n\tlocal response_value\n\t#using the -r option to get unquoted raw output strings\n\tresponse_value=$($DLPX_BIN_JQ -r \".${search_term}\" <<< \"$MONGO_SNAPSHOT_METADATA\")\n\terrorCheck \"Mongo Config Error: Unable to find config value for $search_term (E1)\\n$response_value\"\n\tif [[ \"$response_value\" = \"null\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: Unable to find config value for $search_term (E2)\\n$response_value\"\n\tfi\n\tif [[ -z \"$response_value\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: Unable to find config value for $search_term (E3)\\n$response_value\"\n\tfi\n\t# Set the named response variable to the appropriate value\n\teval $response_variable_name=\\$response_value\n}\n\n# Confirm that the value of the config param on the current host matches the\n# snapshotJson metadata\n# Input params: config term and current value\nfunction confirmSnapshotValue {\n\n\tlocal search_term=\"$1\"\n\tlocal current_value=\"$2\"\n\tif [ $search_term = \"toolkitVersion\" ]\n\tthen\n\t\tMAJOR_TOOLKIT_VERSION=`echo \"$current_value\"|awk -F\".\" '{ print $1 \".\" $2 }'`\n\t\tcurrent_value=$MAJOR_TOOLKIT_VERSION\n\tfi\n\n\tlog \"confirmSnapshotValue: Confirming Snapshot Value --> Search:$search_term Current:$current_value\"\n\n\tif [[ \"$#\" -ne 2 ]]; then\n\t\t\tlog -d \"Mongo Config Error: Incorrect params to confirmConfigValue($@)\"\n\tfi\n\n\tif [[ -z \"$search_term\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: Empty search_term for confirmConfigValue()\"\n\tfi\n\tif [[ -z \"$current_value\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: Empty current_value for confirmConfigValue()\"\n\tfi\n\n\t# Store the snapshot value of the config in a temp variable\n\tgetSnapshotValue \"$search_term\" \"temp_variable\"\n\t# Compare current value of the term against the temp_variable\n\tif [[ \"$current_value\" != \"$temp_variable\" ]]; then\n\t\t\tlog -d \"Mongo Config Error: $search_term of snapshot ($temp_variable) does not match this server ($current_value)\"\n\tfi\n}\n\nfunction parse_yaml {\n   local prefix=$2\n   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\\034')\n   sed -ne \"s|^\\($s\\):|\\1|\" \\\n\t\t-e \"s|^\\($s\\)\\($w\\)$s:$s[\\\"']\\(.*\\)[\\\"']$s\\$|\\1$fs\\2$fs\\3|p\" \\\n\t\t-e \"s|^\\($s\\)\\($w\\)$s:$s\\(.*\\)$s\\$|\\1$fs\\2$fs\\3|p\"  $1 |\n   awk -F$fs '{\n\t  indent = length($1)/2;\n\t  vname[indent] = $2;\n\t  for (i in vname) {if (i > indent) {delete vname[i]}}\n\t  if (length($3) > 0) {\n\t\t vn=\"\"; for (i=0; i<indent; i++) {vn=(vn)(vname[i])(\"_\")}\n\t\t printf(\"%s%s%s=\\\"%s\\\"\\n\", \"'$prefix'\",vn, $2, $3);\n\t  }\n   }'\n}\n\n# Function to grab the primary instance port\nfunction getPrimaryReplica() {\n\tlocal inputReplSetName=$1\n\tlocal allMongoInstances\n\tlocal chkmongod\n\tlocal currentInstance\n\tlocal currentPort\n\tlocal currentReplSetName\n\tlocal currentConfig\n\tlocal primaryReplica\n\n\tlog \"replSetName=$inputReplSetName\"\n\techo \"Function ========\" >> $DEBUG_LOG\n\techo \"Function Library : MONGO_INSTALL_PATH=$MONGO_INSTALL_PATH\" >> $DEBUG_LOG\n\techo \"Function Library : MONGO_SHELL=$MONGO_SHELL\" >> $DEBUG_LOG\n\techo \"Function ========\" >> $DEBUG_LOG\n\n\tprimaryReplica=\"none\"\n\tallMongoInstances=$(ps -ef | grep [m]ongod)\n\tOLD_IFS=\"$IFS\"\n\tIFS=$'\\n'\n\tfor currentInstance in $allMongoInstances\n\tdo \n\t\tlog \"function getPrimaryReplica : $currentInstance\"\n\t\tchkmongod=$(echo \"$currentInstance\" | awk '{ print $8 }')\n\t\tlog \"chkmongod = $chkmongod\"\n\t\tif [[ \"$chkmongod\" == *\"mongod\" ]]\n\t\tthen\n\t\t\tcurrentPort=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\tlog \"currentPort=$currentPort\"\n\t\t\tif [[ -z $currentPort ]]; then\n\t\t\t\t# config files are specified with either -f or --config\n\t\t\t\tlog \"currentInstance = $currentInstance\"\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tlog \"currentConfig=$currentConfig\"\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\tcurrentPort=$(cat $currentConfig | grep -v '^#' | grep '^port=' | sed -e 's/\\port=//g')                \n\t\t\t\t\tif [[ -z $currentPort ]]; then\n\t\t\t\t\t\tcurrentPort=$(cat $currentConfig | grep -v '^#' | grep '^port:' | sed -e 's/\\port://g')\n\t\t\t\t\t\tif [[ -z $currentPort ]]; then\n\t\t\t\t\t\t\tcurrentPort=$(parse_yaml $currentConfig|grep net_port|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\tif [[ -z $currentPort ]]; then\n\t\t\t\t\t\t\t\tcurrentPort=27017\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t#if not found set to default value\n\t\t\t\t\tcurrentPort=27017\n\t\t\t\tfi\n\t\t\t\tcurrentPort=$(echo \"$currentPort\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\tfi\n\t\t\tlog \"currentPort=$currentPort\"\n\t\t\t\n\t\t\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ****** --port $currentPort admin -quiet -eval \\\"db.isMaster().setName\\\"\"\n\t\t\tcurrentReplSetName=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --port $currentPort admin -quiet -eval \"db.isMaster().setName\")\n\t\t\tlog \"currentReplSetName=$currentReplSetName\"\n\t\t\tif [[ -n $(echo $currentReplSetName | grep 'authentication failed') ]]; then\n\t\t\t\tlog \"currentReplSetName=$currentReplSetName\"\n\t\t\t\tcontinue;\n\t\t\tfi\n\t\t\tif [[ -z $currentReplSetName ]]; then\n\t\t\t   # config files are specified with either -f or --config\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\tcurrentReplSetName=$(cat $currentConfig | grep -v '^#' | grep '^replSetName=' | sed -e 's/\\replSetName=//g')                    \n\t\t\t\t\tif [[ -z $currentReplSetName ]]; then\n\t\t\t\t\t\tcurrentReplSetName=$(cat $config | grep -v '^#' | grep '^replSetName:' | sed -e 's/\\replSetName://g')\n\t\t\t\t\t\tif [[ -z $currentReplSetName ]]; then\n\t\t\t\t\t\t\tcurrentReplSetName=$(parse_yaml $currentConfig|grep replication_replSetName|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\tif [[ -z $currentReplSetName ]]; then\n\t\t\t\t\t\t\t\tlog \"No replicaset Name found inline, database or in config file. Please check if you have configured replicaset.\"\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tlog \"No replicaset Name found inline, database and could not find config file. Please check if you have configured replicaset.\"\n\t\t\t\tfi                \n\t\t\tfi\n\t\t\tcurrentReplSetName=$(echo \"$currentReplSetName\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\n\n\t\t\tif [[ $($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD -port \"$currentPort\" admin --quiet --eval \"rs.status().state\") -eq 10 ]]; then\n\t\t\t\tcontinue;\n\t\t\tfi                \n\t\t\tif [[ ! -z \"$currentReplSetName\" ]] ; then\n\t\t\t\tif [[ \"$inputReplSetName\" = \"$currentReplSetName\" ]]; then\n\t\t\t\t\tbreak;\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tdone\n\tprimaryReplica=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD -port \"$currentPort\" admin --quiet --eval \"db.isMaster().primary\")\n\tlog \">> Port : $currentPort\"\n\tlog \">> replSet : $currentReplSetName\"\n\tlog \">> primaryReplica : $primaryReplica\"\n\n\tIFS=\"$OLD_IFS\"\n\techo $primaryReplica\n}\n\n## Function to grab the primary instance port\nfunction findPrimaryReplica {\n\tlocal currentreplicaSet=$1\n\tlocal currentHost=$2\n\tlocal currentPort=$3\n\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\techo \"$MONGO_SHELL -u $MONGO_USER_NAME -p ****** --host $currentHost --port $currentPort --authenticationDatabase admin --quiet --eval 'db.isMaster().primary'\" >> $DEBUG_LOG\n\techo \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\tprimaryReplica=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $currentHost --port $currentPort --authenticationDatabase admin --quiet --eval 'db.isMaster().primary')\n\trc=$?\n\tif [[ $rc -eq 0 ]]; then\n\t\techo $primaryReplica\n\telse\n\t\techo \"none\"\n\tfi\n}\n\n# Function to grab the primary instance port\nfunction mongoinstExists() {\n\tlocal portNum=$1\n\tlocal instances\n\tlocal chkmongod\n\tlocal port\n\tlocal instExists\n\tinstExists=0\n\tinstances=$(ps -ef | grep [m]ongod)\n\tOLD_IFS=\"$IFS\"\n\tIFS=$'\\n'\n\tfor currentInstance in $instances\n\tdo \n\t\tchkmongod=$(echo \"$currentInstance\"| awk '{ print $8 }')\n\t\tif [[ \"$chkmongod\" == *\"mongod\"* ]]\n\t\tthen\n\t\t\tport=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t# config files are specified with either -f or --config\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\t\tport=$(cat $currentConfig | grep -v '^#' | grep '^port=' | sed -e 's/\\port=//g')\n\t\t\t\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t\t\t\tport=$(cat $currentConfig | grep -v '^#' | grep '^port:' | sed -e 's/\\port=//g')\n\t\t\t\t\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t\t\t\t\tport=$(parse_yaml $currentConfig|grep net_port|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t\tport=\"\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ $port = $portNum ]\n\t\t\tthen\n\t\t\t\tinstExists=1\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tinstExists=0\n\t\t\tfi\n\t\tfi\n\tdone\n\tIFS=\"$OLD_IFS\"\n\treturn $instExists\n}\n\ncat_file() \n{\n\techo >> $DEBUG_LOG\n\tlog \"start function : ${FUNCNAME[0]} \"\n\tlocal FILENAME=$1\n\techo \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" >> $DEBUG_LOG\n\tlog \"Contents of File : $FILENAME\"\n\tcat $FILENAME >> $DEBUG_LOG\n\techo \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" >> $DEBUG_LOG\n\tlog \"end function : ${FUNCNAME[0]} \"\n\techo >> $DEBUG_LOG\n\t#echo \"------------------------------------------------------------------------------------------------------------------------------------------\" >> $DEBUG_LOG\n}\n\ncat_variable()\n{\n\techo >> $DEBUG_LOG\t\n\tlog \"start function : ${FUNCNAME[0]} \"\n\tlocal VARNAME=\"$1\"\n\techo \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" >> $DEBUG_LOG\n\tlog \"Contents :\"\n\techo \"$VARNAME\" >> $DEBUG_LOG\n\techo \"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" >> $DEBUG_LOG\n\tlog \"end function : ${FUNCNAME[0]} \"\n\techo >> $DEBUG_LOG\n\t#echo \"------------------------------------------------------------------------------------------------------------------------------------------\" >> $DEBUG_LOG\n}\n\nassemble_snapshotdata()\n{\n\tMAJOR_TOOLKIT_VERSION=`echo \"$TOOLKIT_VERSION\"|awk -F\".\" '{ print $1 \".\" $2 }'`\n\toutputJSON='{}'\n\toutputJSON=$($DLPX_BIN_JQ \".toolkitVersion = $(jqQuote \"$MAJOR_TOOLKIT_VERSION\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".timestamp = $(jqQuote \"$TIMESTAMP\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".architecture = $(jqQuote \"$ARCH\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".osType = $(jqQuote \"$OSTYPE\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".osVersion = $(jqQuote \"$OSVERSION\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".mongoVersion = $(jqQuote \"$MONGO_VERSION\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".delphixMount = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".mongoPort = $MONGO_PORT\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".storageEngine = $(jqQuote \"$MONGO_STORAGE_ENGINE\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".mongoAuth = $(jqQuote \"$MONGO_AUTH\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".replicaSet = $(jqQuote \"$MONGO_REPLICASET\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".journalInterval = $MONGO_JOURNAL_FLUSH\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".oplogSize = $MONGO_OPLOG_SIZE\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".mongoDBUser = $(jqQuote \"$MONGO_USER_NAME\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".mongoDBPassword = $(jqQuote \"$MONGO_USER_PASSWORD\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".dSourceType = $(jqQuote \"$MONGO_DSOURCE_TYPE\")\" <<< \"$outputJSON\")\n\toutputJSON=$($DLPX_BIN_JQ \".appenddbPath = $(jqQuote \"$MONGO_APPEND_DBPATH\")\" <<< \"$outputJSON\")\n}\n\npurgeLogs\n", 
        "recordStatus.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Program Name ...\n#\nPGM_NAME=\"recordStatus.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\ngetSystemInfo\n\nlog \"MONGO_DSOURCE_TYPE = $MONGO_DSOURCE_TYPE\"\nif [ $MONGO_DSOURCE_TYPE = \"emptyStagingFS\" ]; then\n\tNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\n\tif [ -f $NEWDSOURCEFILE ]; then\n\t\tlog \"This condition should never happen. Something wrong in logic\"\n\telse\n\t\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ****** -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \\\"db.serverCmdLineOpts().parsed.storage.dbPath\\\"\"\n\t\tMONGO_DBPATH=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \"db.serverCmdLineOpts().parsed.storage.dbPath\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tlog \"Unable to pull dbPath\"\n\t\t\tMONGO_DBPATH=\"ERROR\"\n\t\t\tMONGO_APPEND_DBPATH=\"ERROR\"\n\t\telse\n\t\t\tMONGO_APPEND_DBPATH=$(basename $MONGO_DBPATH)\n\t\tfi\n\t\tlog \"MONGO_DBPATH = $MONGO_DBPATH\"\n\t\tlog \"MONGO_APPEND_DBPATH = $MONGO_APPEND_DBPATH\"\n\tfi\nelse\n\tMONGO_DBPATH=\"N/A\"\n\tMONGO_APPEND_DBPATH=\"N/A\"\n\tlog \"MONGO_DBPATH = $MONGO_DBPATH\"\n\tlog \"MONGO_APPEND_DBPATH = $MONGO_APPEND_DBPATH\"\nfi\n\n# Lookup the current mongo storage engine\nlog \"$MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p ****** --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(db.serverStatus().storageEngine)\\\"\" \nMONGO_STORAGE_ENGINE=$($MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.serverStatus().storageEngine)\")\nMONGO_STORAGE_ENGINE=$(echo \"$MONGO_STORAGE_ENGINE\" | jq -r '.name')\n# setting default to mmap as 2.6 does not have a value\nif [[ -z \"$MONGO_STORAGE_ENGINE\" ]]; then\n    MONGO_STORAGE_ENGINE='mmapv1'\nfi\n\nlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ****** -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \\\"db.isMaster().setName\\\"\"\nMONGO_REPLICASET=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \"db.isMaster().setName\")\n\n#MONGO_KEYFILE_PATH is set in paramaters for staging. This value is not available on refresh or rewind, so in that case we grep the mongod process to identify whether the keyfile is set or not.\nif [[ $MONGO_STAGING_SERVER_BOOL = true ]]; then\n    if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n        MONGO_AUTH='keyfile'\n    fi\nelse\n    instances=$(ps -ef | grep [m]ongod)\n    #$IFS (internal field separator) determines how Bash recognizes word boundaries\n    #Temporarily set $IFS to \\n (defaults to whitespace)\n    OLD_IFS=\"$IFS\"\n    IFS=$'\\n'\n    for currentInstance in $instances\n\tdo\n\t\tchkmongod=$(echo \"$currentInstance\"| awk '{ print $8 }')\n\t\tif [[ \"$chkmongod\" == *\"mongod\"* ]]\n\t\tthen\n\t\t\tdbPath=$(echo \"$currentInstance\" | grep -Po '(?<=--dbpath\\s)[^\\s]*')\n\t\t\tport=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\tkeyfile=$(echo \"$currentInstance\" | grep -Po '(?<=--keyFile\\s)[^\\s]*')\n\t\t\treplSet=$(echo \"$currentInstance\" | grep -Po '(?<=--replSet\\s)[^\\s]*')\n\t\t\tif [[ $dbPath = ${DLPX_DATA_DIRECTORY} && $port = $MONGO_PORT ]]; then\n\t\t\t\tif [[ ! -z $keyfile ]]; then\n\t\t\t\t\t\tlog \"keyfile not empty ($keyfile), set MONGO_AUTH='keyfile'\"\n\t\t\t\t\t\tMONGO_AUTH='keyfile'\n\t\t\t\tfi\n\t\t\t\tif [[ -z $MONGO_REPLICASET ]]; then\n\t\t\t\t\t\tlog \"MONGO_REPLICASET not set, setting to $replSet\"\n\t\t\t\t\t\tMONGO_REPLICASET=$replSet\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n    done\n    IFS=\"$OLD_IFS\"\nfi\n\nassemble_snapshotdata\n\nif [[ -z $outputJSON ]]; then\n        outputJSON='{}'\nfi\nlog \"outputJSON :\"\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n#echo \"$outputJSON\"|python -m json.tool >> $DEBUG_LOG\nmasksnap=`echo $outputJSON|sed -e 's/\"mongoDBPassword\": \"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\": \"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\nexit 0\n", 
        "mongopresnapsync.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n#DLPX_TOOLKIT_WORKFLOW='resync.lua'\n#DLPX_LIBRARY_SOURCE=`cat /home/delphix/bkp/library.sh`\n#DLPX_DATA_DIRECTORY=/mnt/provision/mongovdb1\n#MONGO_INSTALL_PATH=/u01/mongodb/mongoDB409/bin/mongod\n#MONGO_SHELL=/u01/mongodb/mongoDB409/bin/mongo\n#MONGO_SRC_USER_NAME=ajayt\n#MONGO_SRC_USER_PASSWORD=delphix\n#MONGO_SRC_HOST=192.168.116.140\n#MONGO_SRC_PORT=27101\n#MONGO_USER_NAME=clusteradmin\n#MONGO_USER_PASSWORD=delphix\n#MONGO_PORT=27310\n#DLPX_OUTPUT_FILE=$DLPX_DATA_DIRECTORY/output.log\n\n# Program Name ...\nPGM_NAME=\"mongopresnapsync.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\n\nDATED=`date \\+\\%Y\\%m\\%d_\\%s`\nMONGOBINPATH=$(dirname $MONGO_SHELL)\n\n# Cleanup last run oplogs from staging\nlog \"Cleanup last run oplogs from staging ...\"\nrm -f $DLPX_DATA_DIRECTORY/oplogs/local/*.bson\nerrorChecktReturn \"Unable to cleanup last run oplogs from staging\"\nlog \"Cleanup last run oplogs from staging done\"\n\n# Get new opllogs from source\nlog \"Enable IO freeze on database\"\nlog \"$MONGO_SHELL -u $MONGO_SRC_USER_NAME -p ********** --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \\\"printjson(db.fsyncLock())\\\"\"\n$MONGO_SHELL -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \"printjson(db.fsyncLock())\"\nerrorChecktReturn \"Unable to IO freeze on database\"\nlog \"Enabled IO freeze on database\"\n\nlog \"Find oplog positions\"\ncurrOPLOGPOSINCR=$($MONGO_SHELL local -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \"printjson(db.oplog.rs.find().sort({\\$natural:-1}).limit(1).next().ts)\")\nerrorChecktReturn \"Unable to find current oplog position\"\nlog \"Current oplog position = $currOPLOGPOSINCR\"\n\nOPLOGSTARTPOS=`cat $DLPX_DATA_DIRECTORY/.delphix/oplog.pos.incr`\nerrorChecktReturn \"Unable to find previous oplog position\"\nlog \"Previous OPLOG Position : $OPLOGSTARTPOS\"\n\nlog \"Generate oplog dump\"\n$MONGOBINPATH/mongodump -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin -d local -c oplog.rs -o $DLPX_DATA_DIRECTORY/oplogs --query \"{ \\\"ts\\\" : { \\$gt :  $OPLOGSTARTPOS } }\"\nerrorChecktReturn \"Unable to generate oplog dump\"\nlog \"Generation of oplog dump complete\"\n\n# IMP to write position after oplog dump is taken\nlog \"Write Current OPLOG Position\"\necho $currOPLOGPOSINCR > $DLPX_DATA_DIRECTORY/oplog.pos.incr\nerrorChecktReturn \"Unable to write current OPLOG Position\"\nlog \"Write Current OPLOG Position $DLPX_DATA_DIRECTORY/oplog.pos.incr complete\"\n\nlog \"Disable IO freeze on database\"\nlog \"$MONGO_SHELL -u $MONGO_SRC_USER_NAME -p ********** --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \\\"printjson(db.fsyncUnlock())\\\"\"\n$MONGO_SHELL -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \"printjson(db.fsyncUnlock())\"\nerrorChecktReturn \"Unable to disable IO freeze on database\"\nlog \"Disabled IO freeze on database\"\n\nlog \"Cleanup and prepare for oplog restore on staging\"\n# Rename file to prepare for import\nlog \"`ls -l $DLPX_DATA_DIRECTORY/oplogs/local/*.bson`\"\ncd $DLPX_DATA_DIRECTORY/oplogs/local\nrm -f $DLPX_DATA_DIRECTORY/oplogs/local/*.json\nmv $DLPX_DATA_DIRECTORY/oplogs/local/oplog.rs.bson $DLPX_DATA_DIRECTORY/oplogs/local/oplog.bson\nerrorChecktReturn \"Unable to cleanup and prepare for oplog restore on staging\"\nlog \"Cleanup and prepare for oplog restore on staging complete\"\n\nlog \"Restore oplogs on staging mongo instance\"\n$MONGOBINPATH/mongorestore -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host 127.0.0.1:$MONGO_PORT --authenticationDatabase=admin --quiet --oplogReplay $DLPX_DATA_DIRECTORY/oplogs/local\nerrorChecktReturn \"Unable to restore oplogs on staging mongo instance\"\nlog \"Restore oplogs on staging mongo instance complete\"\n\nlog \"Result : SUCCESS\"\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "shutdown.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"shutdown.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\nlog \"GUID: $VDB_GUID\"\nlog \"MONGO_KEYFILE_PATH: $MONGO_KEYFILE_PATH\"\nlog \"MONGO_REPLICASET: $MONGO_REPLICASET\"\n\nlog \"$MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p ***** --authenticationDatabase admin --quiet --eval \\\"db.getSiblingDB('admin').shutdownServer({force: true})\\\"\"\n\noutput=$($MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"db.getSiblingDB('admin').shutdownServer({force: true})\")\nlog \"Shutting Down Mongo:$output\"\nlog \"Shutdown Complete\"\nexit 0\n", 
        "vdbupdateconfigfile.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Program Name ...\n#\nPGM_NAME=\"vdbupdateconfigfile.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\ngetSystemInfo\n\nCFG_FILE=${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\nMONGO_DSOURCE_TYPE=$(cat ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}|grep \"MONGO_DSOURCE_TYPE\" | awk -F'=' '{ print $2}')\nMONGO_APPEND_DBPATH=$(cat ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}|grep \"MONGO_APPEND_DBPATH\" | awk -F'=' '{ print $2}')\n\n# Lookup the current mongo storage engine\nlog \"$MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p ****** --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(db.serverStatus().storageEngine)\\\"\" \nMONGO_STORAGE_ENGINE=$($MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.serverStatus().storageEngine)\")\nMONGO_STORAGE_ENGINE=$(echo \"$MONGO_STORAGE_ENGINE\" | jq -r '.name')\n# setting default to mmap as 2.6 does not have a value\nif [[ -z \"$MONGO_STORAGE_ENGINE\" ]]; then\n    MONGO_STORAGE_ENGINE='mmapv1'\nfi\n\nMONGO_REPLICASET=\"N/A\"\n\n#MONGO_KEYFILE_PATH is set in paramaters for staging. This value is not available on refresh or rewind, so in that case we grep the mongod process to identify whether the keyfile is set or not.\nif [[ $MONGO_STAGING_SERVER_BOOL = true ]]; then\n    if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n        MONGO_AUTH='keyfile'\n    fi\nelse\n    instances=$(ps -ef | grep [m]ongod)\n    #$IFS (internal field separator) determines how Bash recognizes word boundaries\n    #Temporarily set $IFS to \\n (defaults to whitespace)\n    OLD_IFS=\"$IFS\"\n    IFS=$'\\n'\n    for currentInstance in $instances\n\tdo\n\t\tchkmongod=$(echo \"$currentInstance\"| awk '{ print $8 }')\n\t\tif [[ \"$chkmongod\" == *\"mongod\"* ]]\n\t\tthen\n\t\t\tdbPath=$(echo \"$currentInstance\" | grep -Po '(?<=--dbpath\\s)[^\\s]*')\n\t\t\tport=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\tkeyfile=$(echo \"$currentInstance\" | grep -Po '(?<=--keyFile\\s)[^\\s]*')\n\t\t\treplSet=$(echo \"$currentInstance\" | grep -Po '(?<=--replSet\\s)[^\\s]*')\n\t\t\tif [[ $dbPath = ${DLPX_DATA_DIRECTORY} && $port = $MONGO_PORT ]]; then\n\t\t\t\tif [[ ! -z $keyfile ]]; then\n\t\t\t\t\t\tlog \"keyfile not empty ($keyfile), set MONGO_AUTH='keyfile'\"\n\t\t\t\t\t\tMONGO_AUTH='keyfile'\n\t\t\t\tfi\n\t\t\t\tif [[ -z $MONGO_REPLICASET ]]; then\n\t\t\t\t\t\tlog \"MONGO_REPLICASET not set, setting to $replSet\"\n\t\t\t\t\t\tMONGO_REPLICASET=$replSet\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n    done\n    IFS=\"$OLD_IFS\"\nfi\n\noutput_string=$(printf \"MONGO_STORAGE_ENGINE: $MONGO_STORAGE_ENGINE\")\noutput_string=$(printf \"${output_string}\\nMONGO_AUTH: $MONGO_AUTH\")\noutput_string=$(printf \"${output_string}\\nMONGO_REPLICASET: $MONGO_REPLICASET\")\n#log \"Writing config info to ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}: $output_string\"\n# Write the output data to the config file - overwrites existing\necho \"$output_string\" >${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nsed -i '/MONGO_DSOURCE_TYPE/ d' ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\necho \"MONGO_DSOURCE_TYPE=$MONGO_DSOURCE_TYPE\" >> ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nsed -i '/MONGO_DBPATH/ d' ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\necho \"MONGO_DBPATH=$MONGO_DBPATH\" >> ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nsed -i '/MONGO_APPEND_DBPATH/ d' ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\necho \"MONGO_APPEND_DBPATH=$MONGO_APPEND_DBPATH\" >> ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\ncat_file ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "getHostname.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n\n# Program Name ...\n#\nPGM_NAME=\"getHostname.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\n\necho \"\\\"${hostname}\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "status.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n\n# Program Name ...\nPGM_NAME=\"status.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\n# Get hostname - need this to lookup the member status\nhostname=$(hostname)\n\nlog \"Checking status of instance --> $hostname:$MONGO_PORT\"\nif [ $MONGO_STATUS_TYPE = \"mongodump\" ]; then\n\tlog \"Environment Type : staging\"\nelse\n\tlog \"Environment Type : $MONGO_STATUS_TYPE\"\nfi\n\n# If Mongo process is not found we need to return the \"off\" code\n#current_instance=$(ps -ef | grep [m]ongod | grep \"\\--port $MONGO_PORT\" | grep \"\\--dbpath ${DLPX_DATA_DIRECTORY}\" | wc -l)\n#if [[ $current_instance -eq 0 ]]; then\n#    log \"Unable to find Mongo instance on port $MONGO_PORT with dbpath ${DLPX_DATA_DIRECTORY}\"\n#    printf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n#    exit 0\n#fi\n\n$MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.serverStatus().uptime)\"\nif [[ $? -ne 0 ]]; then\n    log \"Unable to find Mongo instance on port $MONGO_PORT with dbpath ${DLPX_DATA_DIRECTORY}\"\n    printf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n    exit 0\nfi\n#if it is a VDB then exit with success\nif [[ \"$MONGO_STATUS_TYPE\" = \"virtual\" ]]; then\n    log \"life is virtually good on port $MONGO_PORT\"\n    printf \"\\\"ACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n    exit 0\nfi\n\nif [ $MONGO_STATUS_TYPE = \"mongodump\" ]; then\n\tjson=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.runCommand({ serverStatus: 1 }))\")\n\tmongo_state=$(echo \"$json\" | jq \".ok\")\n\terrorCheck \"Unable to check Mongo status ($mongo_state)\"\n\tif [[ $mongo_state -ne 1 ]]; then\n\t\terrorLog \"Mongo is in invalid state : $mongo_state\"\n\t\tprintf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n\t\texit 2\n\tfi\nelse\n\t# For staging servers we will check the replicaset status\n\t#log \"$MONGO_SHELL -u $MONGO_USER_NAME -p ********** --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(rs.status())\\\"\" >> $DEBUG_LOG\n\tjson=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\n\t#log \"$json\"\n\t# We are intentionally supressing errors at .[] so that JQ does not throw an additional error when rs.status fails\n\tmongo_state=$(echo \"$json\" | jq \".members | .[]? | select(.self == true) | .state\")\n\terrorCheck \"Unable to check Mongo status ($mongo_state)\"\n\tif [[ $mongo_state -ne 2 ]]; then\n\t\terrorLog \"Mongo is in invalid state : $mongo_state\"\n\t\tprintf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\n\t\texit 2\n\tfi\nfi\n\nlog \"MongoDB Status at $hostname:$MONGO_PORT - Good\"\nprintf \"\\\"ACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\nexit 0", 
        "chmod777mountpoint.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"chmod777mountpoint.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\nchmod -R 777 $DLPX_DATA_DIRECTORY\nif [ $? -ne 0 ]; then\n\tlog \"Unable to change permissions on delphix mountpoint $DLPX_DATA_DIRECTORY\"\n\techo \"\\\"Unable to change permissions on delphix mountpoint $DLPX_DATA_DIRECTORY.\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nelse\n\tlog \"Permissions modified for delphix mountpoint $DLPX_DATA_DIRECTORY\"\n\techo \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nfi\nexit 0", 
        "startStaging.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n\n# Program Name ...\nPGM_NAME=\"startStaging.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\nlog \"MONGO_REPLICASET=$MONGO_REPLICASET\"\nlog \"MONGO_INSTALL_PATH = $MONGO_INSTALL_PATH\"\nlog \"MONGO_SHELL = $MONGO_SHELL\"\nlog \"MONGO_PORT = $MONGO_PORT\"\nlog \"KEYFILE = $MONGO_KEYFILE_PATH\"\n\nOUTPUT_MSG=\"FAIL\"\n\n# Check for dsource directory and make if not there\nhostname=$(hostname)\nif [[ ! -z $MONGO_KEYFILE_PATH ]]\nthen\n\tkeyFileName=$(basename $MONGO_KEYFILE_PATH)\n\tif [[ -e ${DLPX_DATA_DIRECTORY}/${keyFileName} ]]; then\n\t\tlog \"Staging Mongo instance already running/configured at: $hostname: $MONGO_PORT\"\n\t\techo \"\\\"Staging Mongo instance already running/configured at: $hostname: $MONGO_PORT\\\"\" > $DLPX_OUTPUT_FILE\n\t\texit 0\n\tfi\nfi\n\nlog \"Check if mongo instance already running ...\"\nmongoinstExists $MONGO_PORT\nrc=$?\nlog \"rc = $rc\"\nif [ $rc -ne 0 ]\nthen\n\tlog \"Mongo instance already running at: $hostname: $MONGO_PORT\"\n\techo \"\\\"Mongo instance already running at: $hostname: $MONGO_PORT\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nfi\nlog \"Instance not running.\"\n\nif [[ -d $DLPX_DATA_DIRECTORY ]]; then\n\tlog \"Directory $DLPX_DATA_DIRECTORY already exist\"\nelse\n\tmkdir $DLPX_DATA_DIRECTORY\n\terrorCheck \"Error making directory $DLPX_DATA_DIRECTORY\"\nfi\t\n\nmongoCommand=\"$MONGO_INSTALL_PATH --logpath ${DLPX_DATA_DIRECTORY}/mongod.log --fork --dbpath $DLPX_DATA_DIRECTORY --journal --journalCommitInterval $MONGO_JOURNAL_FLUSH --replSet $MONGO_REPLICASET --oplogSize $MONGO_OPLOG_SIZE --port $MONGO_PORT\"\n\n# If storage engine is anything but mmap we need to add it explicitly. This is because --storageEngine is not a valid param for 2.6\nlog \"MONGO_STORAGE_ENGINE=$MONGO_STORAGE_ENGINE\"\nif [[ \"$MONGO_STORAGE_ENGINE\" != \"mmapv1\" ]]; then\n\tmongoCommand=\"$mongoCommand --storageEngine $MONGO_STORAGE_ENGINE\"\nfi\n\n# Add keyfile only if path is specified\nlog \"MONGO_KEYFILE_PATH=$MONGO_KEYFILE_PATH\"\nif [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n\tmongoCommand=\"$mongoCommand --keyFile $MONGO_KEYFILE_PATH\"\nfi\n\n# Add bind ip if specified\nlog \"MONGO_BIND_IP=$MONGO_BIND_IP\"\nif [[ ! -z \"$MONGO_BIND_IP\" ]]; then\n\tmongoCommand=\"$mongoCommand --bind_ip $MONGO_BIND_IP\"\nfi\n\nlog \"Starting Staging Instance:\"\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\necho \"$mongoCommand\" >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\noutput=$($mongoCommand)\nrc=$?\nlog \"$output\"\nif [ $rc -ne 0 ]; then\n\tlog \"Startup of the staging instance on port $MONGO_PORT failed.\"\n\techo \"\\\"Startup of the staging instance on port $MONGO_PORT failed.\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nfi\n\ncompleted_code=1\nwhile [[ $completed_code -ne 0 ]]\ndo\n\tsleep 10\n\tcheckReplicationStatus\n\tcompleted_code=$?\ndone\n\nOUTPUT_MSG=\"SUCCESS\"\necho \"\\\"$OUTPUT_MSG\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "getStagingConfig.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#\n# Program Name ...\n#\nPGM_NAME=\"getStagingConfig.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\n#DLPX_LIBRARY_SOURCE=`cat /home/mongodb/mongotest/mongo/resources/library.sh`\n#DLPX_BIN_JQ=\"/usr/bin/jq\"\n#DLPX_OUTPUT_FILE=/tmp/a.txt\n\neval \"${DLPX_LIBRARY_SOURCE}\"\nif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\tlog \"Executing $PGM_NAME\"\n\tlog \"------------------------------------------------------- \"\nfi\n\n#add jq to the path\ninitializeJQ\n\ninstallPathFound=0\nshellPathFound=0\ni=0\ne1=0\ne2=0\ne3=0\n\ngetVersion()\n{\n\tCURR_VERSION=$($INSTALLPATH --version | grep \"db version\" | awk '{print $3}')\n\tlog \"CURR_VERSION=$CURR_VERSION\"\n}\n\nassembleJson()\n{\n\t# Assemble JSON and write output variables to output file\n\tCURRENT_REPO='{}'\n\tCURRENT_REPO=$(jq \".mongoInstallPath = $(jqQuote \"$INSTALLPATH\")\" <<< \"$CURRENT_REPO\")\n\tCURRENT_REPO=$(jq \".mongoShellPath = $(jqQuote \"$SHELLPATH\")\" <<< \"$CURRENT_REPO\")\n\tCURRENT_REPO=$(jq \".version = $(jqQuote \"$CURR_VERSION\")\" <<< \"$CURRENT_REPO\")\n}\n\n# See if mongo service exist\n#FIND_BIN_PATH=/m01/app/mongo/product/mongodb #Dell\n\nMANUAL_MONGO_FIND=0\nMANUAL_MONGO_FIND_FILE=$DLPX_REPO_CFGFILE\n#MANUAL_MONGO_FIND_FILE=/tmp/MONGO_INSTALL_PATH.txt\nif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\tlog \"MANUAL_MONGO_FIND_FILE=$MANUAL_MONGO_FIND_FILE\"\nfi\n\nif [ -r $MANUAL_MONGO_FIND_FILE ]\nthen\n\tMANUAL_MONGO_FIND=1\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"Manual/Custom Discovery Enabled\"\n\tfi\nelse\n\tMANUAL_MONGO_FIND=0\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"AutoDiscovery Enabled. Using default path for mongo /usr/bin/mongod\"\n\tfi\nfi\n\nif [ $MANUAL_MONGO_FIND -eq 1 ]; then\n\t#cat $MANUAL_MONGO_FIND_FILE|awk -F\"=\" '{ print $2}'| while read line\n\twhile read line\n\tdo\n\t\tFIND_BIN_PATH=`echo $line|awk -F\"=\" '{ print $2}'`\n\t\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\t\tlog \"Manual Discovery Path Provided : $FIND_BIN_PATH\"\n\t\tfi\n\t\tFIND_BIN_PATH=$(dirname $FIND_BIN_PATH)\n\t\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\t\tlog \"FIND_BIN_PATH : $FIND_BIN_PATH\"\n\t\tfi\n\n\t\tif [ -d $FIND_BIN_PATH ]; then\n\n\t\t\tINSTALLPATH=$(find $FIND_BIN_PATH -name mongod 2>&1 | head -1)\n\t\t\tif [[ ${INSTALLPATH} = *\"Permission denied\"* ]]; then\n\t\t\t\te1=1\n\t\t\t\tlog \"Insufficient privileges to scan $FIND_BIN_PATH\"\n\t\t\telif [[ \"$INSTALLPATH\" = '' ]]; then\n\t\t\t\te2=1\n\t\t\t\t# Install path not found - return empty repo config\n\t\t\t\tlog \"Install path $FIND_BIN_PATH/*..*/mongod not found\"\n\t\t\telse\n\t\t\t\tinstallPathFound=1\n\t\t\t\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\t\t\t\tlog \"INSTALLPATH=$INSTALLPATH\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t\n\t\t\t# See if mongo shell exist\n\t\t\tSHELLPATH=$(find $FIND_BIN_PATH -name mongo | head -1)\n\t\t\tif [[ \"$SHELLPATH\" = '' ]]; then\n\t\t\t\te3=1\n\t\t\t\t# Shell path not found - return empty repo config\n\t\t\t\tlog \"Shell path $FIND_BIN_PATH/*..*/mongo not found\"\n\t\t\telse\n\t\t\t\tshellPathFound=1\n\t\t\t\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\t\t\t\tlog \"SHELLPATH=$SHELLPATH\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t\n\t\t\tgetVersion\n\n\t\t\tif [ $installPathFound -eq 1 ] && [ $shellPathFound -eq 1 ]; then\n\t\t\t\tif [ $MONGO_VERSION = $CURR_VERSION ]; then\n\t\t\t\t\t#log \"Mongo Installations found\"\n\t\t\t\t\tassembleJson\n\t\t\t\t\ti=$(( $i + 1))\n\n\t\t\t\t\techo \"$CURRENT_REPO\" > \"$DLPX_OUTPUT_FILE\"\n\t\t\t\t\terrorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\t\t\t\t\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\t\t\t\t\tlog \"CURRENT_REPO: $CURRENT_REPO\"\n\t\t\t\t\tfi\n\t\t\t\t\t#echo \"`echo $CURRENT_REPO|python -m json.tool`\" >> $DEBUG_LOG\n\t\t\t\t\texit 0\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tlog \"Invalid Path : $line OR Incorrect permissions to access it.\"\n\t\tfi\n\tdone < \t$MANUAL_MONGO_FIND_FILE\n\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"Number of Installations found : $i\"\n\tfi\n\n\tif [ $i -eq 0 ]; then\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\tfi\nelse\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"Auto Discovery\"\n\tfi\n\tFIND_BIN_PATH=/usr/bin\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"FIND_BIN_PATH : $FIND_BIN_PATH\"\n\tfi\n\n\tINSTALLPATH=$(find $FIND_BIN_PATH -name mongod 2>&1 | head -1)\n\tif [[ ${INSTALLPATH} = *\"Permission denied\"* ]]; then\n\t\tlog \"Insufficient privileges to scan $FIND_BIN_PATH\"\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\telif [[ \"$INSTALLPATH\" = '' ]]; then\n\t\t# Install path not found - return empty repo config\n\t\tlog \"Install path $FIND_BIN_PATH/*..*/mongod not found\"\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\tfi\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"INSTALLPATH=$INSTALLPATH\"\n\tfi\n\n\t# See if mongo shell exist\n\tSHELLPATH=$(find $FIND_BIN_PATH -name mongo | head -1)\n\tif [[ \"$SHELLPATH\" = '' ]]; then\n\t\t# Shell path not found - return empty repo config\n\t\tlog \"Shell path $FIND_BIN_PATH/*..*/mongo not found\"\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\tfi\n\tif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\t\tlog \"SHELLPATH=$SHELLPATH\"\n\tfi\n\t\n\tgetVersion\n\tassembleJson\n\nfi\n\necho \"$CURRENT_REPO\" > \"$DLPX_OUTPUT_FILE\"\nerrorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\n#log \"CURRENT_REPO:\"\n#echo \"`echo $CURRENT_REPO|python -m json.tool`\" >> $DEBUG_LOG\nif [ $DLPX_TOOLKIT_WORKFLOW = \"repositoryDiscovery\" ]; then\n\tlog \"CURRENT_REPO:$CURRENT_REPO\"\nfi\n\nexit 0\n", 
        "checkOwnership.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\nset -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"checkOwnership.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\ninstanceExist=$(ps -ef | grep \"\\-\\-port $MONGO_PORT\")\nif [[ $instanceExist != \"\" ]]; then\n    deleteDBPath=$(echo $instanceExist | awk '{for (i=1;i<=NF;i++) if ($i == \"--dbpath\") {print $(i+1)}}')\n    if [[ \"${DLPX_DATA_DIRECTORY}\" == \"$deleteDBPath\" ]]; then\n\techo \"true\" > \"$DLPX_OUTPUT_FILE\"\n    else\n\techo \"false\" > \"$DLPX_OUTPUT_FILE\"\n    fi\nelse\n    echo \"true\" > \"$DLPX_OUTPUT_FILE\"\nfi\nexit 0", 
        "createClusteradmin.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n\n# Program Name ...\nPGM_NAME=\"createClusteradmin.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\nOUTPUT_MSG=\"FAIL\"\nMONGO_DSOURCE_USER_NAME=`echo \"${MONGO_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.mongoDBUser'`\nMONGO_DSOURCE_USER_PASSWORD=`echo \"${MONGO_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.mongoDBPassword'`\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\nlog \"$MONGO_SHELL -u $MONGO_DSOURCE_USER_NAME -p ********** --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(db.getSiblingDB(\\\"admin\\\").runCommand( { createUser: \\\"${MONGO_USER_NAME}\\\", pwd: \\\"**********\\\", roles: [{ role: \\\"clusterAdmin\\\", db: \\\"admin\\\" }]}))\\\"\"                                                                                                                                                    \noutput=$($MONGO_SHELL -u $MONGO_DSOURCE_USER_NAME -p $MONGO_DSOURCE_USER_PASSWORD --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.getSiblingDB(\\\"admin\\\").runCommand( { createUser: \\\"${MONGO_USER_NAME}\\\", pwd: \\\"${MONGO_USER_PASSWORD}\\\", roles: [{ role: \\\"clusterAdmin\\\", db: \\\"admin\\\" }]}))\")\nlog \"output : $output\"\nchkerror=`cat $output|grep \"Error\"|wc -l`\nif [ $chkerror -ne 0 ]; then\n\tlog \"VDB1001 : Not able to connect mongo instance OR add Cluster admin user.\"\n\techo \"\\\"VDB1001 : Not able to connect mongo instance OR add Cluster admin user.\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nelse\n\tsuccess=$(echo \"$output\" | $DLPX_BIN_JQ '.ok')\n\tif [ $success -eq 1 ] # { \"ok\": 1} is success\n\tthen\n\t\tlog \"Success : Added Cluster admin user.\"\n\telse\n\t\tchkDuplicate=$(echo \"$output\" | $DLPX_BIN_JQ '.code')\n\t\tlog \"chkDuplicate=$chkDuplicate\"\n\t\tif [ $chkDuplicate -eq 11000 ] # 11000 is duplicate User\n\t\tthen\n\t\t\tlog \"${MONGO_USER_NAME} User already exists. Updating password.\"\n\t\t\toutput=$($MONGO_SHELL -u $MONGO_DSOURCE_USER_NAME -p $MONGO_DSOURCE_USER_PASSWORD --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.getSiblingDB(\\\"admin\\\").runCommand( { updateUser: \\\"${MONGO_USER_NAME}\\\", pwd: \\\"${MONGO_USER_PASSWORD}\\\"}))\")\n\t\t\tlog \"output : $output\"\n\t\t\tsuccess=$(echo \"$output\" | $DLPX_BIN_JQ '.ok')\n\t\t\tif [ $success -ne 1 ] # { \"ok\": 1}\n\t\t\tthen\n\t\t\t\tlog \"VDB1002 : Not able to update password for Cluster admin user.\"\n\t\t\t\techo \"\\\"VDB1002 : Not able to update password for Cluster admin user.\\\"\" > $DLPX_OUTPUT_FILE\n\t\t\t\texit 0\n\t\t\telse\n\t\t\t\tlog \"Success : Updated password for user ${MONGO_USER_NAME}.\"\n\t\t\tfi\n\t\telse\n\t\t\tlog \"VDB1003 : Not able to update password for Cluster admin user.\"\n\t\t\tlog \"output : $output\"\n\t\t\techo \"\\\"VDB1003 : Not able to update password for Cluster admin user. Please check logfile $DEBUG_LOG\\\"\" > $DLPX_OUTPUT_FILE\n\t\t\texit 0\n\t\tfi\n\tfi\nfi\n\nOUTPUT_MSG=\"SUCCESS\"\necho \"\\\"${OUTPUT_MSG}\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "checkEmptyMountPoint.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#\n# Program Name ...\n#\nPGM_NAME=\"checkEmptyMountPoint.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\n\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\nif [ -d $DLPX_DATA_DIRECTORY ]; then\n\tnooffiles=`ls -l $DLPX_DATA_DIRECTORY|wc -l`\nelse\n\tnooffiles=0\nfi\nif [ $nooffiles -gt 1 ]; then\n\tlog \"Mount Point $DLPX_DATA_DIRECTORY not empty.\"\n\techo \"\\\"NO\\\"\" > $DLPX_OUTPUT_FILE\n\t#ls -l $DLPX_DATA_DIRECTORY >> $DEBUG_LOG\nelse\n\tlog \"Mount Point $DLPX_DATA_DIRECTORY is empty.\"\n\techo \"\\\"YES\\\"\" > $DLPX_OUTPUT_FILE\nfi\n\nexit 0\n", 
        "fsyncLock.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"fsyncLock.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\nNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\nif [ -f $NEWDSOURCEFILE ]; then\n\t# This is to handle OPS Manager workflow\n\tlog \"File $NEWDSOURCEFILE exists. This is initial staging instance provisioning\"\n\techo \"\\\"SKIP_SAVEKEYFILE\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nelse\n\tlog \"Quisce mongo on $MONGO_HOST:$MONGO_PORT\"\n\n\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \\\"db.fsyncLock();\\\"\"\n\toutput=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"db.fsyncLock();\")\n\tif [ $? -ne 0 ]; then\n\t\tlog \"Quisce mongo on $MONGO_HOST:$MONGO_PORT Failed\"\n\t\techo \"\\\"Quisce mongo on $MONGO_HOST:$MONGO_PORT Failed.\\\"\" > $DLPX_OUTPUT_FILE\n\t\texit 0\n\tfi\n\tlog \"Output:\\n$output\"\n\tsuccess=$(echo \"$output\" | jq '.ok')\n\tif [ $success -eq 0 ]\n\tthen\n\t\t\tcode=$(echo \"$output\" | jq '.code')\n\t\t\terrmsg=$(echo \"$output\" | jq '.errmsg')\n\t\t\tlog \"db.fsyncLock() failed: Code: $code error:  $errmsg\"\n\t\t\techo \"\\\"db.fsyncLock() failed: Code: $code error:  $errmsg.\\\"\" > $DLPX_OUTPUT_FILE\n\t\t\texit 0\n\telse\n\t\t\tlog \"db.fsyncLock() succeeded\"\n\tfi\n\n\techo \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nfi\nexit 0", 
        "repoDiscovery.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#\n# Program Name ...\n#\nPGM_NAME=\"repoDiscovery.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\n#DLPX_LIBRARY_SOURCE=`cat /home/mongodb/mongotest/mongo/resources/library.sh`\n#DLPX_BIN_JQ=\"/usr/bin/jq\"\n#DLPX_OUTPUT_FILE=/tmp/a.txt\n\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\ninstallPathFound=0\nshellPathFound=0\ni=0\ne1=0\ne2=0\ne3=0\nREPOSITORIES='[]'\n\ngetVersion()\n{\n\tVERSION=$($INSTALLPATH --version)\n\tif [ $? -ne 0 ]\n\tthen\n\t\tlog -d \"Unable to run command \\\"$INSTALLPATH --version\\\" to capture the version of Mongo. Please check your Environment.\"\n\t\terrorLog \"Unable to run command \\\"$INSTALLPATH --version\\\" to capture the version of Mongo. Please check your Environment.\"\n\telse\n\t\tVERSION=$(echo $VERSION  | grep \"db version\" | awk '{print $3}'\t)\n\t\tlog \"VERSION=$VERSION\"\n\tfi\n}\n\nassembleJson()\n{\n\t# Assemble JSON and write output variables to output file\n\tCURRENT_REPO='{}'\n\tPRETTYNAME=\"EDSI MongoDB (${VERSION})\"\n\tCURRENT_REPO=$(jq \".mongoInstallPath = $(jqQuote \"$INSTALLPATH\")\" <<< \"$CURRENT_REPO\")\n\tCURRENT_REPO=$(jq \".mongoShellPath = $(jqQuote \"$SHELLPATH\")\" <<< \"$CURRENT_REPO\")\n\tCURRENT_REPO=$(jq \".version = $(jqQuote \"$VERSION\")\" <<< \"$CURRENT_REPO\")\n\tCURRENT_REPO=$(jq \".prettyName = $(jqQuote \"$PRETTYNAME\")\" <<< \"$CURRENT_REPO\")\n\tREPOSITORIES=$(jq \". + [$CURRENT_REPO]\" <<< \"$REPOSITORIES\")\n}\n\n# See if mongo service exist\n#FIND_BIN_PATH=/m01/app/mongo/product/mongodb #Dell\n\nMANUAL_MONGO_FIND=0\nMANUAL_MONGO_FIND_FILE=$DLPX_REPO_CFGFILE\n#MANUAL_MONGO_FIND_FILE=/tmp/MONGO_INSTALL_PATH.txt\nlog \"MANUAL_MONGO_FIND_FILE=$MANUAL_MONGO_FIND_FILE\"\n\nif [ -r $MANUAL_MONGO_FIND_FILE ]\nthen\n\tMANUAL_MONGO_FIND=1\n\tlog \"Manual/Custom Discovery Enabled\"\nelse\n\tMANUAL_MONGO_FIND=0\n\tlog \"AutoDiscovery Enabled. Using default path for mongo /usr/bin/mongod\"\nfi\n\nif [ $MANUAL_MONGO_FIND -eq 1 ]; then\n\t#cat $MANUAL_MONGO_FIND_FILE|awk -F\"=\" '{ print $2}'| while read line\n\twhile read line\n\tdo\n\t\tif [[ ${line} = *\"MONGO_PATH\"* ]]; then\n\t\t\tFIND_BIN_PATH=`echo $line|awk -F\"=\" '{ print $2}'`\n\t\t\tlog \"Manual Discovery Path Provided : $FIND_BIN_PATH\"\n\t\t\tFIND_BIN_PATH=$(dirname $FIND_BIN_PATH)\n\t\t\tlog \"FIND_BIN_PATH : $FIND_BIN_PATH\"\n\n\t\t\tif [ -d $FIND_BIN_PATH ]; then\n\n\t\t\t\tINSTALLPATH=$(find $FIND_BIN_PATH -name mongod 2>&1 | head -1)\n\t\t\t\tif [[ ${INSTALLPATH} = *\"Permission denied\"* ]]; then\n\t\t\t\t\te1=1\n\t\t\t\t\tlog \"Insufficient privileges to scan $FIND_BIN_PATH\"\n\t\t\t\telif [[ \"$INSTALLPATH\" = '' ]]; then\n\t\t\t\t\te2=1\n\t\t\t\t\t# Install path not found - return empty repo config\n\t\t\t\t\tlog \"Install path $FIND_BIN_PATH/*..*/mongod not found\"\n\t\t\t\telse\n\t\t\t\t\tinstallPathFound=1\n\t\t\t\t\tlog \"INSTALLPATH=$INSTALLPATH\"\n\t\t\t\tfi\n\t\t\t\t\n\t\t\t\t# See if mongo shell exist\n\t\t\t\tSHELLPATH=$(find $FIND_BIN_PATH -name mongo | head -1)\n\t\t\t\tif [[ \"$SHELLPATH\" = '' ]]; then\n\t\t\t\t\te3=1\n\t\t\t\t\t# Shell path not found - return empty repo config\n\t\t\t\t\tlog \"Shell path $FIND_BIN_PATH/*..*/mongo not found\"\n\t\t\t\telse\n\t\t\t\t\tshellPathFound=1\n\t\t\t\t\tlog \"SHELLPATH=$SHELLPATH\"\n\t\t\t\tfi\n\t\t\t\t\n\t\t\t\tgetVersion\n\n\t\t\t\tif [ $installPathFound -eq 1 ] && [ $shellPathFound -eq 1 ]; then\n\t\t\t\t\tlog \"Mongo Installations found\"\n\t\t\t\t\tassembleJson\n\t\t\t\t\ti=$(( $i + 1))\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tlog \"Invalid Path : $line OR Incorrect permissions to access it.\"\n\t\t\tfi\n\t\tfi\n\tdone < \t$MANUAL_MONGO_FIND_FILE\n\n\tlog \"Number of Installations found : $i\"\n\n\tif [ $i -eq 0 ]; then\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\tfi\nelse\n\tlog \"Auto Discovery\"\n\tFIND_BIN_PATH=/usr/bin\n\tlog \"FIND_BIN_PATH : $FIND_BIN_PATH\"\n\n\tINSTALLPATH=$(find $FIND_BIN_PATH -name mongod 2>&1 | head -1)\n\tif [[ ${INSTALLPATH} = *\"Permission denied\"* ]]; then\n\t\tlog \"Insufficient privileges to scan $FIND_BIN_PATH\"\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\telif [[ \"$INSTALLPATH\" = '' ]]; then\n\t\t# Install path not found - return empty repo config\n\t\tlog \"Install path $FIND_BIN_PATH/*..*/mongod not found\"\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\tfi\n\tlog \"INSTALLPATH=$INSTALLPATH\"\n\n\t# See if mongo shell exist\n\tSHELLPATH=$(find $FIND_BIN_PATH -name mongo | head -1)\n\tif [[ \"$SHELLPATH\" = '' ]]; then\n\t\t# Shell path not found - return empty repo config\n\t\tlog \"Shell path $FIND_BIN_PATH/*..*/mongo not found\"\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\texit 0\n\tfi\n\tlog \"SHELLPATH=$SHELLPATH\"\n\t\n\tgetVersion\n\tassembleJson\n\nfi\n\necho \"$REPOSITORIES\" > \"$DLPX_OUTPUT_FILE\"\nerrorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\nlog \"REPOSITORIES:\"\necho \"`echo $REPOSITORIES|python -m json.tool`\" >> $DEBUG_LOG\n\nexit 0\n", 
        "checkMongoLogin.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\nset -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"checkMongoLogin.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\n\n# Grab the primary replication port and host\nprimaryReplica=$(getPrimaryReplica \"$MONGO_REPLICASET\")\nlog \"Primary Replica : $primaryReplica\"\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\n#For MongodDB  <= 2.8, need to specify an unused _id value in the replica set\nlog \"\\n mongo -u $MONGO_USER_NAME -p ***** --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \\\"printjson(JSON.stringify(rs.status()))\"\\\"\njson=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host \"$primaryHost\" --port \"$primaryPort\" --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.status())\")\n\nlog \"rs.status:\\n$json\"\n#_id An integer identifier of every member in the replica set. Values must be between 1 and 255 inclusive.\n#see https://docs.mongodb.org/manual/reference/replica-configuration/#rsconf.members[n]._id\nfor i in {0..255}; do\n    member=$(echo \"$json\" | jq \".members | .[] | select(._id == $i)\")\n    if [ -z \"$member\" ]; then\n        new_id=$i\n        log \"New ID for staging instance : $new_id\"\n        break\n    else\n        log \"Member $i : Already Exists \"\n    fi\ndone\n\nif [ -z \"$new_id\" ]; then\n    die \"no valid ids available in replica set\"\nfi\n\nlog \"Adding Delphix staging host $MONGO_STANDBY_HOST:${MONGO_PORT} to replica set with _id=$new_id\"\nlog \"\\n mongo -u $MONGO_USER_NAME -p ***** --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(rs.add({host:'${MONGO_STANDBY_HOST}:${MONGO_PORT}', priority: 0, hidden: true, _id: $new_id}))\\\"\"\noutput=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.add({host:'${MONGO_STANDBY_HOST}:${MONGO_PORT}', priority: 0, hidden: true, _id: $new_id}))\")\nsuccess=$(echo \"$output\" | jq '.ok')\n#Code 103 = Found two member configurations with same host field, meaning staging server already added\nif [ $success -eq 0 ]\nthen\n    code=$(echo \"$output\" | jq '.code')\n    errmsg=$(echo \"$output\" | jq '.errmsg')\n    log \"Failed : rs.add({host:\\'$MONGO_STANDBY_HOST:${MONGO_PORT}\\', priority: 0, hidden: true, _id: $new_id})\"\n    die \"rs.add failed: Code: $code error:  $errmsg\"\nelse\n    log \"Success : rs.add({host:\\'$MONGO_STANDBY_HOST:${MONGO_PORT}\\', priority: 0, hidden: true, _id: $new_id})\"\nfi\n\nexit 0\n", 
        "writeLibrary.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n# writeLibrary.sh\n#\n# Library of common mongo toolkit functions ... \n#\n\n###########################################################\n## Required Environment Variables ...\n\n#\n# Delphix Supplied Environment Variables ...\n# \n# DLPX_BIN_JQ=`which jq`\n# DLPX_DATA_DIRECTORY\n# \n# Additional Data Specific ...\n#\n# ? DLPX_TMP_DIRECTORY\n#\n# \n# Toolkit Specific ..\n# \nDLPX_TOOLKIT_NAME=\"mongo\" \nDLPX_LOG_DIRECTORY=\"/tmp\"               # =\"${DLPX_DATA_DIRECTORY}/..\"\n\n###########################################################\n## Globals\n\nTOOLKIT_VERSION=\"0.9.1\"\nTIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)\nCONFIG_OUTPUT_FILE=\"delphix_${DLPX_TOOLKIT_NAME}_config.dat\"\nERROR_LOG=\"${DLPX_LOG_DIRECTORY}/delphix${DLPX_TOOLKIT_NAME}error.log\"\nDEBUG_LOG=\"${DLPX_LOG_DIRECTORY}/delphix${DLPX_TOOLKIT_NAME}debug.log\"\n\n###########################################################\n## Functions ...\n\n#\n# Log infomation and die if option -d is used.\n#\nfunction log {\n   Parms=$@\n   die='no'\n   if [[ $1 = '-d' ]]; then\n      shift\n      die='yes'\n      Parms=$@\n   fi\n   #printf \"[${TIMESTAMP}][DEBUG][%s][%s]:[$Parms]\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME\n   printf \"[${TIMESTAMP}][DEBUG][%s][%s]:[$Parms]\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME >>$DEBUG_LOG\n   if [[ $die = 'yes' ]]; then\n      exit 2\n   fi\n}\n\n# Log error and write to the errorlog\nfunction errorLog {\n    log \"$@\"\n    printf \"[${TIMESTAMP}][ERROR][%s][%s]:[$Parms]\\n\" $DLPX_TOOLKIT_WORKFLOW $PGM_NAME >>$ERROR_LOG\n}\n\n# Write to log and errorlog before exiting with an error code\nfunction die {\n    errorLog \"$@\"\n    exit 2\n}\n\n# Function to check for errors and die with passed in error message\nfunction errorCheck {\n    if [ $? -ne 0 ]; then\n        die \"$@\"\n    fi\n}\n\nif [ -z \"$DLPX_LIBRARY_SOURCE\" ]; then\n        die \"Mongo Library Error: Unable to load Mongo Library source \"\nfi\n\necho \"$DLPX_LIBRARY_SOURCE\" >${DLPX_DATA_DIRECTORY}/../delphixMongoFunctions.lib\nerrorCheck \"Mongo Library Error: Unable to write Mongo Library to ${DLPX_DATA_DIRECTORY}/../delphixMongoFunctions.lib\"\n\nlog \"Wrote library.sh to ${DLPX_DATA_DIRECTORY}/../delphixMongoFunctions.lib\"", 
        "mongofulldumpandrestore.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Testing Parameters\n#DLPX_TOOLKIT_WORKFLOW='resync.lua'\n#DLPX_LIBRARY_SOURCE=`cat /home/delphix/bkp/library.sh`\n#DLPX_DATA_DIRECTORY=/mnt/provision/mongovdb1\n#MONGO_INSTALL_PATH=/u01/mongodb/mongoDB409/bin/mongod\n#MONGO_SHELL=/u01/mongodb/mongoDB409/bin/mongo\n#MONGO_SRC_USER_NAME=ajayt\n#MONGO_SRC_USER_PASSWORD=delphix\n#MONGO_SRC_HOST=192.168.116.140\n#MONGO_SRC_PORT=27101\n#MONGO_USER_NAME=clusteradmin\n#MONGO_USER_PASSWORD=delphix\n#MONGO_PORT=27310\n#DLPX_OUTPUT_FILE=$DLPX_DATA_DIRECTORY/output.log\n\n# Program Name ...\nPGM_NAME=\"mongofulldumpandrestore.sh\"             # used in log and errorLog\n\n# Load Library ...\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\n\n#add jq to the path\ninitializeJQ\n\n# Grab the host we are running this script on\nhostname=$(hostname)\nlog \"Current host : $hostname\"\n\nDATED=`date \\+\\%Y\\%m\\%d_\\%s`\nMONGOBINPATH=$(dirname $MONGO_SHELL)\nlog \"Enable IO freeze on database...\"\n$MONGO_SHELL -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \"printjson(db.fsyncLock())\"\nerrorChecktReturn \"Unable to IO freeze on database\"\nlog \"Enabled IO freeze on database\"\n\nlog \"Find current oplog position\"\ncurrOPLOGPOS=$($MONGO_SHELL local -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \"printjson(db.oplog.rs.find().sort({\\$natural:-1}).limit(1).next().ts)\")\nerrorChecktReturn \"Unable to find current oplog position\"\nlog \"Current oplog position = $currOPLOGPOS\"\nlog \"Write oplog position to file\"\necho $currOPLOGPOS > $DLPX_DATA_DIRECTORY/.delphix/oplog.pos\ncp -p $DLPX_DATA_DIRECTORY/.delphix/oplog.pos $DLPX_DATA_DIRECTORY/.delphix/oplog.pos.incr\nerrorChecktReturn \"Unable to write oplog position to file $DLPX_DATA_DIRECTORY/.delphix/oplog.pos\"\nlog \"Write oplog position to file done.\"\n\nlog \"Generate mongodump of source database $MONGO_SRC_HOST:$MONGO_SRC_PORT\"\n$MONGOBINPATH/mongodump -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --oplog --gzip -o $DLPX_DATA_DIRECTORY/$DATED\nerrorChecktReturn \"Unable to generate mongodump\"\nlog \"Generated mongodump\"\nlog \"Dump folder = $DLPX_DATA_DIRECTORY/$DATED\"\nlog \"`du -sh $DLPX_DATA_DIRECTORY/$DATED`\"\n\nlog \"Disable IO freeze on database\"\n$MONGO_SHELL -u $MONGO_SRC_USER_NAME -p $MONGO_SRC_USER_PASSWORD --host $MONGO_SRC_HOST:$MONGO_SRC_PORT --authenticationDatabase=admin --quiet --eval \"printjson(db.fsyncUnlock())\"\nerrorChecktReturn \"Unable to disable IO freeze on database\"\nlog \"Disabled IO freeze on database\"\n\nlog \"Restore staging mongo instance\"\n$MONGOBINPATH/mongorestore -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host 127.0.0.1:$MONGO_PORT --authenticationDatabase=admin --quiet --gzip --dir=$DLPX_DATA_DIRECTORY/$DATED\nerrorChecktReturn \"Unable to restore dump of database\"\nlog \"Restored dump to staging instance\"\n\nlog \"Result : SUCCESS\"\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "emptyrecordStatus.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Program Name ...\n#\nPGM_NAME=\"emptyrecordStatus.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\ngetSystemInfo\n\n# setting default to mmap as 2.6 does not have a value\nif [[ -z \"$MONGO_STORAGE_ENGINE\" ]]; then\n    MONGO_STORAGE_ENGINE='mmapv1'\nfi\n\n#MONGO_KEYFILE_PATH is set in paramaters for staging. This value is not available on refresh or rewind, so in that case we grep the mongod process to identify whether the keyfile is set or not.\nif [[ $MONGO_STAGING_SERVER_BOOL = true ]]; then\n    if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n        MONGO_AUTH='keyfile'\n    fi\nfi\n\nlog \"MONGO_DSOURCE_TYPE = $MONGO_DSOURCE_TYPE\"\nif [ $MONGO_DSOURCE_TYPE = \"emptyStagingFS\" ]; then\n\tNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\n\tif [ -f $NEWDSOURCEFILE ]; then\n\t\tlog \"File $NEWDSOURCEFILE exists. This is initial staging instance provisioning\"\n\t\tMONGO_DBPATH=\"N/A\"\n\t\tMONGO_APPEND_DBPATH=\"N/A\"\n\t\tlog \"$NEWDSOURCEFILE : deleting file\"\n\t\trm -f $NEWDSOURCEFILE\n\t\tlog \"$NEWDSOURCEFILE : file deleted.\"\n\telse\n\t\tlog \"This condition should never happen. Please check logic\"\n\tfi\nelse\n\tlog \"This condition should never happen. Something wrong in logic\"\nfi\n\nassemble_snapshotdata\n\nif [[ -z $outputJSON ]]; then\n        outputJSON='{}'\nfi\nlog \"outputJSON :\"\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n#echo \"$outputJSON\"|python -m json.tool >> $DEBUG_LOG\nmasksnap=`echo $outputJSON|sed -e 's/\"mongoDBPassword\": \"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\": \"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\nexit 0\n", 
        "dropStagingFromPrimary.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\nset -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"dropStagingFromPrimary.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\nlog \"Removing Delphix staging host $MONGO_HOST:$MONGO_PORT from replica set\"\nlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p *****\"\n# Grab the primary replication port and host\nprimaryReplica=$( findPrimaryReplica $MONGO_REPLICASET $MONGO_HOST $MONGO_PORT  )\nlog \"primaryReplica Params = $MONGO_REPLICASET $MONGO_HOST $MONGO_PORT\"\nlog \"primaryReplica = $primaryReplica\"\nprimaryHost=$(echo $primaryReplica | cut -d \":\" -f 1)\nprimaryPort=$(echo $primaryReplica | cut -d \":\" -f 2)\n\nlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \\\"rs.remove('${MONGO_HOST}:${MONGO_PORT}'))\\\"\"\noutput=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \"JSON.stringify(rs.remove('${MONGO_HOST}:${MONGO_PORT}'))\")\nlog \"Output: $output\"\nsuccess=$(echo \"$output\" | jq '.ok')\nif [ $success -eq 0 ]\nthen\n        code=$(echo \"$output\" | jq '.code')\n        errmsg=$(echo \"$output\" | jq '.errmsg')\n        die \"rs.add failed: Code: $code error:  $errmsg\"\nelse\n        log \"rs.remove succeeded\"\nfi\n\nlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \\\"printjson(rs.status())\\\"\"\noutput=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $primaryHost --port $primaryPort --authenticationDatabase admin --quiet --eval \"printjson(rs.status())\")\necho \"$output\"|python -m json.tool >> $DEBUG_LOG\n#remainingMembers=$(echo \"$output\" | jq -r \".members | .[] | .name\")\n#echo \"========\" >> $DEBUG_LOG\n#log \"$remainingMembers\"\n#echo \"========\" >> $DEBUG_LOG\n\nexit 0", 
        "provision.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"provision.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\ngetSystemInfo\nMONGO_HOST=`hostname`\nif [[ -z \"$MONGO_SNAPSHOT_METADATA\" ]]; then\n\techo \"Mongo Provisioning Error: Empty snapshot metadata ($MONGO_SNAPSHOT_METADATA)\"\n\techo \"\\\"Mongo Provisioning Error: Empty snapshot metadata ($MONGO_SNAPSHOT_METADATA)\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\n    #log -d \"Mongo Provisioning Error: Empty snapshot metadata ($MONGO_SNAPSHOT_METADATA)\"\n    #exit 2\t\nfi\n\n#MONGO_USER_NAME=`echo \"${MONGO_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.mongoDBUser'`\n#MONGO_USER_PASSWORD=`echo \"${MONGO_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.mongoDBPassword'`\n\nlog \"Snapshot Metadata :\"\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n#echo $MONGO_SNAPSHOT_METADATA|python -m json.tool >> $DEBUG_LOG\nmasksnap=`echo $MONGO_SNAPSHOT_METADATA|sed -e 's/\"mongoDBPassword\":\"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\":\"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\nCFG_FILE=${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\nlog \"CFG_FILE = $CFG_FILE\"\ncat_file $CFG_FILE\n\n\nsnapshotVersion=$MONGO_SNAPSHOT_METADATA\nconfirmSnapshotValue \"toolkitVersion\" \"$TOOLKIT_VERSION\"\nconfirmSnapshotValue \"architecture\" \"$ARCH\"\nconfirmSnapshotValue \"osType\" \"$OSTYPE\"\nconfirmSnapshotValue \"osVersion\" \"$OSVERSION\"\n#confirmSnapshotValue \"mongoVersion\" \"$MONGO_VERSION\"\ngetSnapshotValue \"storageEngine\" \"MONGO_STORAGE_ENGINE\"\n\n#if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n#    getSnapshotValue \"mongoAuth\" \"MONGO_AUTH\"\n#fi\n##getSnapshotValue \"replicaSet\" \"MONGO_REPLICASET\"\n\n# Check if there is an existing instance on Mongo listening on that port number\nlog \"Checking for existing Mongo instance at $MONGO_PORT\"\nmongoinstExists $MONGO_PORT\nif [ $? -ne 0 ]; then\n\tlog \"\\\"VERROR:0001 : Mongo instance already running at: $hostname: $MONGO_PORT\\\"\"\n\techo \"\\\"VERROR:0001 : Mongo instance already running at: $hostname: $MONGO_PORT\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nfi\n\nlog \"MONGO_ENABLE_KEYFILE = $MONGO_ENABLE_KEYFILE\"\nif [ $MONGO_ENABLE_KEYFILE = 'Y' ]; then\n\tlog \"MONGO_ENABLE_KEYFILE = $MONGO_ENABLE_KEYFILE\"\n\tkeyFileName=${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\n\t#if [[ -e $keyFileName ]]; then\n\t#\trm -f $keyFileName\n\t#fi\n\tif [[ ! -z $MONGO_KEYFILE_PATH ]] ; then\n\t\tlog \"`ls -l $MONGO_ENABLE_KEYFILE`\"\n\t\tif [[ -e $MONGO_KEYFILE_PATH ]]; then\n\t\t\tcopyCommand=$(which cp)\n\t\t\t$copyCommand -f $MONGO_KEYFILE_PATH $keyFileName\n\t\t\tlog \"`ls -l $keyFileName`\"\n\t\tfi\n\tfi\nfi\n\n#output_string=$(printf \"MONGO_STORAGE_ENGINE: $MONGO_STORAGE_ENGINE\")\n#output_string=$(printf \"${output_string}\\nMONGO_AUTH: $MONGO_AUTH\")\n##output_string=$(printf \"${output_string}\\nMONGO_REPLICASET: $MONGO_REPLICASET\")\n## Write the output data to the config file - overwrites existing\n#echo \"$output_string\" >${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\n\nprettyName=\"Mongo:$MONGO_PORT - ${DLPX_DATA_DIRECTORY}\"\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".mongoHost = $(jqQuote \"$MONGO_HOST\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".mongoPort = \"$MONGO_PORT\"\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".replicaSet = $(jqQuote \"N/A\")\" <<< \"$outputJSON\")\n#outputJSON=$($DLPX_BIN_JQ \".mongoDBUser = $(jqQuote \"$MONGO_USER_NAME\")\" <<< \"$outputJSON\")\n#outputJSON=$($DLPX_BIN_JQ \".mongoDBPassword = $(jqQuote \"$MONGO_USER_PASSWORD\")\" <<< \"$outputJSON\")\n\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\nmasksnap=`echo $outputJSON|sed -e 's/\"mongoDBPassword\": \"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\":\"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\n\nCFG_FILE=${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\nlog \"CFG_FILE = $CFG_FILE\"\ncat_file $CFG_FILE\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\n\nexit 0\n", 
        "initializeVDB.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"initializeVDB.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\nSTATUS_FILE=${DLPX_DATA_DIRECTORY}/status-${VDB_GUID}\n\n# Making sure the sentinel file exists.\ntouch ${STATUS_FILE}\n", 
        "sourceConfigDiscovery.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"sourceConfigDiscovery.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\n. $HOME/.setDelphixMongoEnv\nHOST_NAME=`hostname`\n# Check to see Mongo Version or install path are empty\nif [[ \"$MONGO_VERSION\" = '' ]] || [[ \"$MONGO_INSTALL_PATH\" = '' ]]; then\n        #die 'MONGO_VERSION or MONGO_INSTALL_PATH not set when doing source config discovery'\n\t\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\t\tlog \"MONGO_VERSION or MONGO_INSTALL_PATH is not set.\"\n\t\texit 0\nfi\n\nexport PATH=$MONGO_INSTALL_PATH:$PATH\nlog \"MONGO_VERSION      : $MONGO_VERSION\"\nlog \"MONGO_INSTALL_PATH : $MONGO_INSTALL_PATH\"\nlog \"MONGO_SHELL        : $MONGO_SHELL\"\ninsufficientPriv=0\nsourceConfigFound=0\n\n# Find the mongo instances\ninstances=$(ps -ef | grep [m]ongod)\n#errorCheck \"Error finding Mongo instances \\n${instances}\"\n\n# Get configs for each instance\nsourceConfigs='[]'\nOLD_IFS=\"$IFS\"\nIFS=$'\\n'\nfor currentInstance in $instances\ndo \n    chkmongod=$(echo \"$currentInstance\"| awk '{ print $8 }'); \n    if [[ $chkmongod == *\"mongod\" ]]\n    then\n        log \"currentInstance=$currentInstance\"\n        log \"Current Mongo Instance: $chkmongod\"\n\t\tCURR_VERSION=$($chkmongod --version | grep \"db version\" | awk '{print $3}')\n\t\tlog \"VERSION=$CURR_VERSION\"\n\n\t\tif [ $MONGO_VERSION = $CURR_VERSION ]; then\n\t\t\tdbPath=$(echo \"$currentInstance\" | grep -Po '(?<=--dbpath\\s)[^\\s]*')\n\t\t\tport=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\treplicaSet=$(echo \"$currentInstance\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--replSet\") {print $(i+1)}}')\n\t\t\tkeyFilePath=$(echo \"$currentInstance\" | awk '{for (i=1;i<=NF;i++) if ($i == \"--keyFile\") {print $(i+1)}}')\n\t\t\tlog \"Inline Parameters : dbPath = $dbPath, port=$port, replicaSet=$replicaSet, keyFilePath=$keyFilePath\"\n\n\t\t\tif [[ -z $dbPath ]] ; then\n\t\t\t\t# config files are specified with either -f or --config\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tlog \"currentConfig=$currentConfig\"\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\t\tif [ -r $currentConfig ];\n\t\t\t\t\t\tthen\n\t\t\t\t\t\t\tlog \"Permissions to read file $currentConfig - Good\"\n\t\t\t\t\t\t\tdbPath=$(cat $currentConfig | grep -v '^#' | grep '^dbpath=' | sed -e 's/\\dbpath=//g')\n\t\t\t\t\t\t\tif [[ -z $dbPath ]] ; then\n\t\t\t\t\t\t\t\tlog \"dbPath not yet found.\"\n\t\t\t\t\t\t\t\tdbPath=$(cat $currentConfig | grep -v '^#' | grep '^dbpath:' | sed -e 's/\\dbpath=//g')\n\t\t\t\t\t\t\t\tif [[ -z $dbPath ]] ; then\n\t\t\t\t\t\t\t\t\tlog \"dbPath not yet found..\"\n\t\t\t\t\t\t\t\t\tdbPath=$(parse_yaml $currentConfig|grep storage_dbPath|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\t\t\tif [[ -z $dbPath ]] ; then\n\t\t\t\t\t\t\t\t\t\tlog \"dbPath not yet found...\"\n\t\t\t\t\t\t\t\t\t\tlog \"Now using default dbPath\"\n\t\t\t\t\t\t\t\t\t\tdbPath=\"/data/db\"\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tinsufficientPriv=0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlog \"Insufficient Permissions to read file $currentConfig.\"\n\t\t\t\t\t\t\tinsufficientPriv=1\n\t\t\t\t\t\tfi\n\n\t\t\t\telse\n\t\t\t\t\t\t#if not found set to default value\n\t\t\t\t\t\tlog \"currentConfig: $currentConfig not found. Using default dbPath\"\n\t\t\t\t\t\tdbPath=\"/data/db\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t# config files are specified with either -f or --config\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tlog \"currentConfig=$currentConfig\"\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\t\tif [ -r $currentConfig ];\n\t\t\t\t\t\tthen\n\t\t\t\t\t\t\techo \"Permissions to read file $currentConfig - Good\"\n\t\t\t\t\t\t\tport=$(cat $currentConfig | grep -v '^#' | grep '^port=' | sed -e 's/\\port=//g')\n\t\t\t\t\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t\t\t\t\tlog \"port not yet found.\"\n\t\t\t\t\t\t\t\tport=$(cat $currentConfig | grep -v '^#' | grep '^port:' | sed -e 's/\\port=//g')\n\t\t\t\t\t\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t\t\t\t\t\tlog \"port not yet found..\"\n\t\t\t\t\t\t\t\t\tport=$(parse_yaml $currentConfig|grep net_port|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\t\t\tif [[ -z $port ]] ; then\n\t\t\t\t\t\t\t\t\t\tlog \"port not yet found...\"\n\t\t\t\t\t\t\t\t\t\tlog \"Now using default port\"\n\t\t\t\t\t\t\t\t\t\tport=\"27017\"\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tinsufficientPriv=0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"Insufficient Permissions to read file $currentConfig.\"\n\t\t\t\t\t\t\tinsufficientPriv=1\n\t\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t\t#if not found set to default value\n\t\t\t\t\t\tlog \"currentConfig: $currentConfig not found. Using default port\"\n\t\t\t\t\t\tport=\"27017\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tif [[ -z $keyFilePath ]] ; then\n\t\t\t\t# config files are specified with either -f or --config\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tlog \"currentConfig=$currentConfig\"\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\t\tif [ -r $currentConfig ];\n\t\t\t\t\t\tthen\n\t\t\t\t\t\t\techo \"Permissions to read file $currentConfig - Good\"\n\t\t\t\t\t\t\tkeyFilePath=$(cat $currentConfig | grep -v '^#' | grep '^keyFilePath=' | sed -e 's/\\keyFilePath=//g')\n\t\t\t\t\t\t\tif [[ -z $keyFilePath ]] ; then\n\t\t\t\t\t\t\t\tlog \"keyFilePath not yet found.\"\n\t\t\t\t\t\t\t\tkeyFilePath=$(cat $currentConfig | grep -v '^#' | grep '^keyFilePath:' | sed -e 's/\\keyFilePath=//g')\n\t\t\t\t\t\t\t\tif [[ -z $keyFilePath ]] ; then\n\t\t\t\t\t\t\t\t\tlog \"keyFilePath not yet found..\"\n\t\t\t\t\t\t\t\t\tkeyFilePath=$(parse_yaml $currentConfig|grep security_keyFile|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\t\t\tif [[ -z $keyFilePath ]] ; then\n\t\t\t\t\t\t\t\t\t\tlog \"keyFilePath not yet found...\"\n\t\t\t\t\t\t\t\t\t\tkeyFilePath=\"\"\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tinsufficientPriv=0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"Insufficient Permissions to read file $currentConfig.\"\n\t\t\t\t\t\t\tinsufficientPriv=1\n\t\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t\t#if not found set to default value\n\t\t\t\t\t\tlog \"currentConfig: $currentConfig not found. Using default dbPath\"\n\t\t\t\t\t\tkeyFilePath=\"\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tif [[ -z $replicaSet ]] ; then\n\t\t\t\t# config files are specified with either -f or --config\n\t\t\t\tcurrentConfig=$(echo \"$currentInstance\" | grep -Po '(?<=-f\\s|--config\\s)[^\\s]*')\n\t\t\t\tlog \"currentConfig=$currentConfig\"\n\t\t\t\tif [[ ! -z $currentConfig ]]; then\n\t\t\t\t\t\tif [ -r $currentConfig ];\n\t\t\t\t\t\tthen\n\t\t\t\t\t\t\techo \"Permissions to read file $currentConfig - Good\"\n\t\t\t\t\t\t\treplicaSet=$(cat $currentConfig | grep -v '^#' | grep '^replSetName=' | sed -e 's/\\replSetName=//g')\n\t\t\t\t\t\t\tif [[ -z $replicaSet ]] ; then\n\t\t\t\t\t\t\t\tlog \"replicaSet not yet found.\"\n\t\t\t\t\t\t\t\treplicaSet=$(cat $currentConfig | grep -v '^#' | grep '^replSetName:' | sed -e 's/\\replSetName=//g')\n\t\t\t\t\t\t\t\tif [[ -z $replicaSet ]] ; then\n\t\t\t\t\t\t\t\t\tlog \"replicaSet not yet found..\"\n\t\t\t\t\t\t\t\t\treplicaSet=$(parse_yaml $currentConfig|grep replication_replSetName|awk -F\"=\" '{print $2}'|sed 's/\"//g')\n\t\t\t\t\t\t\t\t\tif [[ -z $replicaSet ]] ; then\n\t\t\t\t\t\t\t\t\t\tlog \"replicaSet not yet found...\"\n\t\t\t\t\t\t\t\t\t\treplicaSet=\"N/A\"\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tlog \"replicaSet = $replicaSet\"\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tinsufficientPriv=0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"Insufficient Permissions to read file $currentConfig.\"\n\t\t\t\t\t\t\tinsufficientPriv=1\n\t\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t\t#if not found set to default value\n\t\t\t\t\t\tlog \"currentConfig: $currentConfig not found..\"\n\t\t\t\t\t\treplicaSet=\"\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tif [ $insufficientPriv -eq 0 ]; then\n\t\t\t\tlog \"Discovered Parameters : dbPath = $dbPath, port=$port, replicaSet=$replicaSet, keyFilePath=$keyFilePath\"\n\n\t\t\t\tif [[ -z $replicaSet ]] || [[ $replicaSet = \"\" ]] || [[ $replicaSet = \"N/A\" ]] ; then\n\t\t\t\t\tlog \"Instance does not have replicaSet defined so ignoring it.\"\n\t\t\t\telse\n\t\t\t\t\tisdelphixInstance=$(df -h /mnt/provision/mongostg|grep \"domain0/group-\"|wc -l)\n\t\t\t\t\tlog \"isdelphixInstance = $isdelphixInstance\"\n\t\t\t\t\tif [ $isdelphixInstance -eq 0 ]; then\n\t\t\t\t\t\tmyhostnameraw=$(hostname)\n\t\t\t\t\t\treplicaSet=$replicaSet\n\t\t\t\t\t\tprettyName=\"Mongo_${port} $dbPath\"\n\t\t\t\t\t\tlog \"prettyName=$prettyName\"\n\t\t\t\t\t\tDISCOVERYTYPE=\"Auto\"\n\t\t\t\t\t\tcurrentSourceConfig='{}'\n\t\t\t\t\t\tcurrentSourceConfig=$(jq \".mongoHost = $(jqQuote \"$myhostnameraw\")\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\tcurrentSourceConfig=$(jq \".mongoPort = $port\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\tcurrentSourceConfig=$(jq \".dbPath = $(jqQuote \"$dbPath\")\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\tcurrentSourceConfig=$(jq \".replicaSet = $(jqQuote \"$replicaSet\")\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\t##currentSourceConfig=$(jq \".keyfilePath = $(jqQuote \"$keyFilePath\")\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\tcurrentSourceConfig=$(jq \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\tcurrentSourceConfig=$(jq \".discoveryType = $(jqQuote \"$DISCOVERYTYPE\")\" <<< \"$currentSourceConfig\")\n\t\t\t\t\t\tsourceConfigs=$(jq \". + [$currentSourceConfig]\" <<< \"$sourceConfigs\")\n\t\t\t\t\t\tsourceConfigFound=1\t\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tlog \"Not a Instance of Current Repository\"\n\t\tfi\n    fi\ndone\nIFS=\"$OLD_IFS\"\n\nif [ $sourceConfigFound -eq 0 ]; then\n\t#currentSourceConfig='{}'\n\t#sourceConfigs=$(jq \". + [$currentSourceConfig]\" <<< \"$sourceConfigs\")\n\techo \"[]\" >\"$DLPX_OUTPUT_FILE\"\n\tlog \"No running Mongo instance found.\"\n\t#errorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\texit 0\nfi\n\n#log \"Source Configs: $sourceConfigs\"\nmasksnap=`echo $sourceConfigs|sed -e 's/\"mongoDBPassword\": \"'$MONGO_PASSWORD'\"/\"mongoDBPassword\":\"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\n\necho \"$sourceConfigs\" > \"$DLPX_OUTPUT_FILE\"\nerrorCheck \"Error writing to $DLPX_OUTPUT_FILE\"\n\nexit 0", 
        "vdbsourceConfig.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"vdbsourceConfig.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\nMONGO_HOST=`hostname`\nMONGO_REPLICASET=\"N/A\"\nlog \"Snapshot Metadata :\"\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n#echo $MONGO_SNAPSHOT_METADATA|python -m json.tool >> $DEBUG_LOG\nmasksnap=`echo $MONGO_SNAPSHOT_METADATA|sed -e 's/\"mongoDBPassword\":\"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\":\"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\n#MONGO_USER_NAME=`echo \"${MONGO_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.mongoDBUser'`\n#MONGO_USER_PASSWORD=`echo \"${MONGO_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.mongoDBPassword'`\nDISCOVERYTYPE=\"Manual\"\nprettyName=\"Mongo:${MONGO_PORT} - $DLPX_DATA_DIRECTORY\"\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".mongoHost = $(jqQuote \"$MONGO_HOST\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".mongoPort = \"$MONGO_PORT\"\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".replicaSet = $(jqQuote \"N/A\")\" <<< \"$outputJSON\")\n#outputJSON=$($DLPX_BIN_JQ \".mongoDBUser = $(jqQuote \"$MONGO_USER_NAME\")\" <<< \"$outputJSON\")\n#outputJSON=$($DLPX_BIN_JQ \".mongoDBPassword = $(jqQuote \"$MONGO_USER_PASSWORD\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".discoveryType = $(jqQuote \"$DISCOVERYTYPE\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$outputJSON\")\n\nmasksnap=`echo $outputJSON|sed -e 's/\"mongoDBPassword\": \"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\":\"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nexit 0\n", 
        "saveKeyFile.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\nset -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"saveKeyFile.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\nNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\nif [ -f $NEWDSOURCEFILE ]; then\n\t# This is to handle Mongo OPS Manager workflow\n\tlog \"File $NEWDSOURCEFILE exists. This is initial provisioning\"\n\techo \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nelse\n\t# save keyfile only if path is specified\n\tif [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n\t\tlog \"Saving Keyfile $MONGO_KEYFILE_PATH to ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\"\n\t\tcopyCommand=$(which cp)\n\t\t$copyCommand -f $MONGO_KEYFILE_PATH ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\n\t\tif [ $? -ne 0 ]; then\n\t\t\tlog \"Failed to copy keyauth file from $MONGO_KEYFILE_PATH to ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\"\n\t\tfi\n\t\t#errorCheck \"Snapshot error: Unable to save keyfile $MONGO_KEYFILE_PATH to ${DLPX_DATA_DIRECTORY}/delphixKeyfile.pem\"\n\tfi\nfi\n\nexit 0\n", 
        "fsyncUnlock.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n#set -xv\n\n#\n# Program Name ...\n#\nPGM_NAME=\"fsyncUnlock.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\n\n# If part is for staging workflow with Mongo OPS Manager. N/A for VDB\nNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\nif [ -f $NEWDSOURCEFILE ]; then\n\tlog \"File $NEWDSOURCEFILE exists. This is initial staging instance provisioning\"\n\techo \"\\\"SKIP_SAVEKEYFILE\\\"\" > $DLPX_OUTPUT_FILE\n\texit 0\nelse\n\tlog \"UnQuisce mongo on $MONGO_HOST:$MONGO_PORT\"\n\n\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ***** --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \\\"db.fsyncUnlock();\\\"\"\n\toutput=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --host $MONGO_HOST --port $MONGO_PORT --authenticationDatabase admin --quiet --eval \"db.fsyncUnlock();\")\n\tif [ $? -ne 0 ]; then\n\t\tlog \"UnQuisce mongo on $MONGO_HOST:$MONGO_PORT Failed\"\n\t\techo \"\\\"UnQuisce mongo on $MONGO_HOST:$MONGO_PORT Failed.\\\"\" > $DLPX_OUTPUT_FILE\n\t\texit 0\n\tfi\n\tlog \"Output:$output\"\n\tsuccess=$(echo \"$output\" | jq '.ok')\n\tif [ $success -eq 0 ]\n\tthen\n\t\t\tcode=$(echo \"$output\" | jq '.code')\n\t\t\terrmsg=$(echo \"$output\" | jq '.errmsg')\n\t\t\tlog \"db.fsyncUnlock() failed: Code: $code error:  $errmsg\"\n\t\t\techo \"\\\"db.fsyncUnlock() failed: Code: $code error:  $errmsg.\\\"\" > $DLPX_OUTPUT_FILE\n\t\t\texit 0\n\telse\n\t\t\tlog \"db.fsyncUnlock() succeeded\"\n\tfi\nfi\n\necho \"\\\"SUCCESS\\\"\" > $DLPX_OUTPUT_FILE\nexit 0\n", 
        "vdbrecordStatus.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n#\n##DEBUG## In Delphix debug.log\n# Program Name ...\n#\nPGM_NAME=\"vdbrecordStatus.sh\"             # used in log and errorLog\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"Executing $PGM_NAME\"\nlog \"------------------------------------------------------- \"\n\n#add jq to the path\ninitializeJQ\ngetSystemInfo\n\nCFG_FILE=${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}\nMONGO_DSOURCE_TYPE=$(cat ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}|grep \"MONGO_DSOURCE_TYPE\" | awk -F'=' '{ print $2}')\nMONGO_APPEND_DBPATH=$(cat ${DLPX_DATA_DIRECTORY}/${CONFIG_OUTPUT_FILE}|grep \"MONGO_APPEND_DBPATH\" | awk -F'=' '{ print $2}')\n\n# Lookup the current mongo storage engine\nlog \"$MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p ****** --authenticationDatabase admin --quiet --eval \\\"JSON.stringify(db.serverStatus().storageEngine)\\\"\" \nMONGO_STORAGE_ENGINE=$($MONGO_SHELL 127.0.0.1:$MONGO_PORT -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD --authenticationDatabase admin --quiet --eval \"JSON.stringify(db.serverStatus().storageEngine)\")\nMONGO_STORAGE_ENGINE=$(echo \"$MONGO_STORAGE_ENGINE\" | jq -r '.name')\n# setting default to mmap as 2.6 does not have a value\nif [[ -z \"$MONGO_STORAGE_ENGINE\" ]]; then\n    MONGO_STORAGE_ENGINE='mmapv1'\nfi\n\nMONGO_REPLICASET=\"N/A\"\n\n#MONGO_KEYFILE_PATH is set in paramaters for staging. This value is not available on refresh or rewind, so in that case we grep the mongod process to identify whether the keyfile is set or not.\nif [[ $MONGO_STAGING_SERVER_BOOL = true ]]; then\n    if [[ ! -z \"$MONGO_KEYFILE_PATH\" ]]; then\n        MONGO_AUTH='keyfile'\n    fi\nelse\n    instances=$(ps -ef | grep [m]ongod)\n    #$IFS (internal field separator) determines how Bash recognizes word boundaries\n    #Temporarily set $IFS to \\n (defaults to whitespace)\n    OLD_IFS=\"$IFS\"\n    IFS=$'\\n'\n    for currentInstance in $instances\n\tdo\n\t\tchkmongod=$(echo \"$currentInstance\"| awk '{ print $8 }')\n\t\tif [[ \"$chkmongod\" == *\"mongod\"* ]]\n\t\tthen\n\t\t\tdbPath=$(echo \"$currentInstance\" | grep -Po '(?<=--dbpath\\s)[^\\s]*')\n\t\t\tport=$(echo \"$currentInstance\" | grep -Po '(?<=--port\\s)[^\\s]*' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\t\t\tkeyfile=$(echo \"$currentInstance\" | grep -Po '(?<=--keyFile\\s)[^\\s]*')\n\t\t\treplSet=$(echo \"$currentInstance\" | grep -Po '(?<=--replSet\\s)[^\\s]*')\n\t\t\tif [[ $dbPath = ${DLPX_DATA_DIRECTORY} && $port = $MONGO_PORT ]]; then\n\t\t\t\tif [[ ! -z $keyfile ]]; then\n\t\t\t\t\t\tlog \"keyfile not empty ($keyfile), set MONGO_AUTH='keyfile'\"\n\t\t\t\t\t\tMONGO_AUTH='keyfile'\n\t\t\t\tfi\n\t\t\t\tif [[ -z $MONGO_REPLICASET ]]; then\n\t\t\t\t\t\tlog \"MONGO_REPLICASET not set, setting to $replSet\"\n\t\t\t\t\t\tMONGO_REPLICASET=$replSet\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n    done\n    IFS=\"$OLD_IFS\"\nfi\n\nlog \"MONGO_DSOURCE_TYPE = $MONGO_DSOURCE_TYPE\"\nif [ $MONGO_DSOURCE_TYPE = \"emptyStagingFS\" ]; then\n\tNEWDSOURCEFILE=${DLPX_DATA_DIRECTORY}/NEWDSOURCEFILE.cfg\n\tlog \"$MONGO_SHELL -u $MONGO_USER_NAME -p ****** -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \\\"db.serverCmdLineOpts().parsed.storage.dbPath\\\"\"\n\tMONGO_DBPATH=$($MONGO_SHELL -u $MONGO_USER_NAME -p $MONGO_USER_PASSWORD -port $MONGO_PORT --authenticationDatabase admin -quiet -eval \"db.serverCmdLineOpts().parsed.storage.dbPath\")\n\tif [ $? -ne 0 ]; then\n\t\tlog \"Unable to pull dbPath\"\n\t\tMONGO_DBPATH=\"ERROR\"\n\t\tMONGO_APPEND_DBPATH=\"ERROR\"\n\telse\n\t\tMONGO_APPEND_DBPATH=$(basename $MONGO_DBPATH)\n\tfi\n\tlog \"MONGO_DBPATH = $MONGO_DBPATH\"\n\tlog \"MONGO_APPEND_DBPATH = $MONGO_APPEND_DBPATH\"\nelse\n\tMONGO_DBPATH=\"N/A\"\n\tMONGO_APPEND_DBPATH==\"N/A\"\n\tlog \"MONGO_DBPATH = $MONGO_DBPATH\"\n\tlog \"MONGO_APPEND_DBPATH = $MONGO_APPEND_DBPATH\"\nfi\n\nassemble_snapshotdata\n\nif [[ -z $outputJSON ]]; then\n        outputJSON='{}'\nfi\nlog \"outputJSON :\"\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n#echo \"$outputJSON\"|python -m json.tool >> $DEBUG_LOG\nmasksnap=`echo $outputJSON|sed -e 's/\"mongoDBPassword\": \"'$MONGO_USER_PASSWORD'\"/\"mongoDBPassword\": \"**********\"/g'`\necho \"$masksnap\"|python -m json.tool >> $DEBUG_LOG\necho \"============================================================================================================================================================\"  >> $DEBUG_LOG\n\nexit 0\n"
    }
}